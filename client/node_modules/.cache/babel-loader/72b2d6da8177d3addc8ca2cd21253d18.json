{"ast":null,"code":"'use strict';\n\nconst Hoek = require('@hapi/hoek');\n\nconst Any = require('../any');\n\nconst Cast = require('../../cast');\n\nconst Ref = require('../../ref');\n\nconst internals = {};\ninternals.Alternatives = class extends Any {\n  constructor() {\n    super();\n    this._type = 'alternatives';\n\n    this._invalids.remove(null);\n\n    this._inner.matches = [];\n  }\n\n  _init(...args) {\n    return args.length ? this.try(...args) : this;\n  }\n\n  _base(value, state, options) {\n    const errors = [];\n    const il = this._inner.matches.length;\n    const baseType = this._baseType;\n\n    for (let i = 0; i < il; ++i) {\n      const item = this._inner.matches[i];\n\n      if (!item.schema) {\n        const schema = item.peek || item.is;\n        const input = item.is ? item.ref(state.reference || state.parent, options) : value;\n\n        const failed = schema._validate(input, null, options, state.parent).errors;\n\n        if (failed) {\n          if (item.otherwise) {\n            return item.otherwise._validate(value, state, options);\n          }\n        } else if (item.then) {\n          return item.then._validate(value, state, options);\n        }\n\n        if (i === il - 1 && baseType) {\n          return baseType._validate(value, state, options);\n        }\n\n        continue;\n      }\n\n      const result = item.schema._validate(value, state, options);\n\n      if (!result.errors) {\n        // Found a valid match\n        return result;\n      }\n\n      errors.push(...result.errors);\n    }\n\n    if (errors.length) {\n      return {\n        errors: this.createError('alternatives.child', {\n          reason: errors\n        }, state, options)\n      };\n    }\n\n    return {\n      errors: this.createError('alternatives.base', null, state, options)\n    };\n  }\n\n  try(...schemas) {\n    schemas = Hoek.flatten(schemas);\n    Hoek.assert(schemas.length, 'Cannot add other alternatives without at least one schema');\n    const obj = this.clone();\n\n    for (let i = 0; i < schemas.length; ++i) {\n      const cast = Cast.schema(this._currentJoi, schemas[i]);\n\n      if (cast._refs.length) {\n        obj._refs.push(...cast._refs);\n      }\n\n      obj._inner.matches.push({\n        schema: cast\n      });\n    }\n\n    return obj;\n  }\n\n  when(condition, options) {\n    let schemaCondition = false;\n    Hoek.assert(Ref.isRef(condition) || typeof condition === 'string' || (schemaCondition = condition instanceof Any), 'Invalid condition:', condition);\n    Hoek.assert(options, 'Missing options');\n    Hoek.assert(typeof options === 'object', 'Invalid options');\n\n    if (schemaCondition) {\n      Hoek.assert(!options.hasOwnProperty('is'), '\"is\" can not be used with a schema condition');\n    } else {\n      Hoek.assert(options.hasOwnProperty('is'), 'Missing \"is\" directive');\n    }\n\n    Hoek.assert(options.then !== undefined || options.otherwise !== undefined, 'options must have at least one of \"then\" or \"otherwise\"');\n    const obj = this.clone();\n    let is;\n\n    if (!schemaCondition) {\n      is = Cast.schema(this._currentJoi, options.is);\n\n      if (options.is === null || !(Ref.isRef(options.is) || options.is instanceof Any)) {\n        // Only apply required if this wasn't already a schema or a ref, we'll suppose people know what they're doing\n        is = is.required();\n      }\n    }\n\n    const item = {\n      ref: schemaCondition ? null : Cast.ref(condition),\n      peek: schemaCondition ? condition : null,\n      is,\n      then: options.then !== undefined ? Cast.schema(this._currentJoi, options.then) : undefined,\n      otherwise: options.otherwise !== undefined ? Cast.schema(this._currentJoi, options.otherwise) : undefined\n    };\n\n    if (obj._baseType) {\n      item.then = item.then && obj._baseType.concat(item.then);\n      item.otherwise = item.otherwise && obj._baseType.concat(item.otherwise);\n    }\n\n    if (!schemaCondition) {\n      Ref.push(obj._refs, item.ref);\n\n      obj._refs.push(...item.is._refs);\n    }\n\n    if (item.then && item.then._refs.length) {\n      obj._refs.push(...item.then._refs);\n    }\n\n    if (item.otherwise && item.otherwise._refs.length) {\n      obj._refs.push(...item.otherwise._refs);\n    }\n\n    obj._inner.matches.push(item);\n\n    return obj;\n  }\n\n  label(name) {\n    const obj = super.label(name);\n    obj._inner.matches = obj._inner.matches.map(match => {\n      if (match.schema) {\n        return {\n          schema: match.schema.label(name)\n        };\n      }\n\n      match = Object.assign({}, match);\n\n      if (match.then) {\n        match.then = match.then.label(name);\n      }\n\n      if (match.otherwise) {\n        match.otherwise = match.otherwise.label(name);\n      }\n\n      return match;\n    });\n    return obj;\n  }\n\n  describe() {\n    const description = super.describe();\n    const alternatives = [];\n\n    for (let i = 0; i < this._inner.matches.length; ++i) {\n      const item = this._inner.matches[i];\n\n      if (item.schema) {\n        // try()\n        alternatives.push(item.schema.describe());\n      } else {\n        // when()\n        const when = item.is ? {\n          ref: item.ref.toString(),\n          is: item.is.describe()\n        } : {\n          peek: item.peek.describe()\n        };\n\n        if (item.then) {\n          when.then = item.then.describe();\n        }\n\n        if (item.otherwise) {\n          when.otherwise = item.otherwise.describe();\n        }\n\n        alternatives.push(when);\n      }\n    }\n\n    description.alternatives = alternatives;\n    return description;\n  }\n\n};\nmodule.exports = new internals.Alternatives();","map":{"version":3,"sources":["C:/Users/Asus A455L/portfolio-rizky/portfolio2/client/node_modules/@hapi/joi/lib/types/alternatives/index.js"],"names":["Hoek","require","Any","Cast","Ref","internals","Alternatives","constructor","_type","_invalids","remove","_inner","matches","_init","args","length","try","_base","value","state","options","errors","il","baseType","_baseType","i","item","schema","peek","is","input","ref","reference","parent","failed","_validate","otherwise","then","result","push","createError","reason","schemas","flatten","assert","obj","clone","cast","_currentJoi","_refs","when","condition","schemaCondition","isRef","hasOwnProperty","undefined","required","concat","label","name","map","match","Object","assign","describe","description","alternatives","toString","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst Hoek = require('@hapi/hoek');\n\nconst Any = require('../any');\nconst Cast = require('../../cast');\nconst Ref = require('../../ref');\n\n\nconst internals = {};\n\n\ninternals.Alternatives = class extends Any {\n\n    constructor() {\n\n        super();\n        this._type = 'alternatives';\n        this._invalids.remove(null);\n        this._inner.matches = [];\n    }\n\n    _init(...args) {\n\n        return args.length ? this.try(...args) : this;\n    }\n\n    _base(value, state, options) {\n\n        const errors = [];\n        const il = this._inner.matches.length;\n        const baseType = this._baseType;\n\n        for (let i = 0; i < il; ++i) {\n            const item = this._inner.matches[i];\n            if (!item.schema) {\n                const schema = item.peek || item.is;\n                const input = item.is ? item.ref(state.reference || state.parent, options) : value;\n                const failed = schema._validate(input, null, options, state.parent).errors;\n\n                if (failed) {\n                    if (item.otherwise) {\n                        return item.otherwise._validate(value, state, options);\n                    }\n                }\n                else if (item.then) {\n                    return item.then._validate(value, state, options);\n                }\n\n                if (i === (il - 1) && baseType) {\n                    return baseType._validate(value, state, options);\n                }\n\n                continue;\n            }\n\n            const result = item.schema._validate(value, state, options);\n            if (!result.errors) {     // Found a valid match\n                return result;\n            }\n\n            errors.push(...result.errors);\n        }\n\n        if (errors.length) {\n            return { errors: this.createError('alternatives.child', { reason: errors }, state, options) };\n        }\n\n        return { errors: this.createError('alternatives.base', null, state, options) };\n    }\n\n    try(...schemas) {\n\n        schemas = Hoek.flatten(schemas);\n        Hoek.assert(schemas.length, 'Cannot add other alternatives without at least one schema');\n\n        const obj = this.clone();\n\n        for (let i = 0; i < schemas.length; ++i) {\n            const cast = Cast.schema(this._currentJoi, schemas[i]);\n            if (cast._refs.length) {\n                obj._refs.push(...cast._refs);\n            }\n\n            obj._inner.matches.push({ schema: cast });\n        }\n\n        return obj;\n    }\n\n    when(condition, options) {\n\n        let schemaCondition = false;\n        Hoek.assert(Ref.isRef(condition) || typeof condition === 'string' || (schemaCondition = condition instanceof Any), 'Invalid condition:', condition);\n        Hoek.assert(options, 'Missing options');\n        Hoek.assert(typeof options === 'object', 'Invalid options');\n        if (schemaCondition) {\n            Hoek.assert(!options.hasOwnProperty('is'), '\"is\" can not be used with a schema condition');\n        }\n        else {\n            Hoek.assert(options.hasOwnProperty('is'), 'Missing \"is\" directive');\n        }\n\n        Hoek.assert(options.then !== undefined || options.otherwise !== undefined, 'options must have at least one of \"then\" or \"otherwise\"');\n\n        const obj = this.clone();\n        let is;\n        if (!schemaCondition) {\n            is = Cast.schema(this._currentJoi, options.is);\n\n            if (options.is === null || !(Ref.isRef(options.is) || options.is instanceof Any)) {\n\n                // Only apply required if this wasn't already a schema or a ref, we'll suppose people know what they're doing\n                is = is.required();\n            }\n        }\n\n        const item = {\n            ref: schemaCondition ? null : Cast.ref(condition),\n            peek: schemaCondition ? condition : null,\n            is,\n            then: options.then !== undefined ? Cast.schema(this._currentJoi, options.then) : undefined,\n            otherwise: options.otherwise !== undefined ? Cast.schema(this._currentJoi, options.otherwise) : undefined\n        };\n\n        if (obj._baseType) {\n\n            item.then = item.then && obj._baseType.concat(item.then);\n            item.otherwise = item.otherwise && obj._baseType.concat(item.otherwise);\n        }\n\n        if (!schemaCondition) {\n            Ref.push(obj._refs, item.ref);\n            obj._refs.push(...item.is._refs);\n        }\n\n        if (item.then && item.then._refs.length) {\n            obj._refs.push(...item.then._refs);\n        }\n\n        if (item.otherwise && item.otherwise._refs.length) {\n            obj._refs.push(...item.otherwise._refs);\n        }\n\n        obj._inner.matches.push(item);\n\n        return obj;\n    }\n\n    label(name) {\n\n        const obj = super.label(name);\n        obj._inner.matches = obj._inner.matches.map((match) => {\n\n            if (match.schema) {\n                return { schema: match.schema.label(name) };\n            }\n\n            match = Object.assign({}, match);\n            if (match.then) {\n                match.then = match.then.label(name);\n            }\n\n            if (match.otherwise) {\n                match.otherwise = match.otherwise.label(name);\n            }\n\n            return match;\n        });\n        return obj;\n    }\n\n    describe() {\n\n        const description = super.describe();\n        const alternatives = [];\n        for (let i = 0; i < this._inner.matches.length; ++i) {\n            const item = this._inner.matches[i];\n            if (item.schema) {\n\n                // try()\n\n                alternatives.push(item.schema.describe());\n            }\n            else {\n\n                // when()\n\n                const when = item.is ? {\n                    ref: item.ref.toString(),\n                    is: item.is.describe()\n                } : {\n                    peek: item.peek.describe()\n                };\n\n                if (item.then) {\n                    when.then = item.then.describe();\n                }\n\n                if (item.otherwise) {\n                    when.otherwise = item.otherwise.describe();\n                }\n\n                alternatives.push(when);\n            }\n        }\n\n        description.alternatives = alternatives;\n        return description;\n    }\n\n};\n\n\nmodule.exports = new internals.Alternatives();\n"]},"metadata":{},"sourceType":"script"}