{"ast":null,"code":"'use strict';\n\nconst Util = require('util');\n\nconst Hoek = require('@hapi/hoek');\n\nconst Any = require('../any');\n\nconst internals = {};\ninternals.Map = class extends Map {\n  slice() {\n    return new internals.Map(this);\n  }\n\n  toString() {\n    return Util.inspect(this);\n  }\n\n};\ninternals.Symbol = class extends Any {\n  constructor() {\n    super();\n    this._type = 'symbol';\n    this._inner.map = new internals.Map();\n  }\n\n  _base(value, state, options) {\n    if (options.convert) {\n      const lookup = this._inner.map.get(value);\n\n      if (lookup) {\n        value = lookup;\n      }\n\n      if (this._flags.allowOnly) {\n        return {\n          value,\n          errors: typeof value === 'symbol' ? null : this.createError('symbol.map', {\n            value,\n            map: this._inner.map\n          }, state, options)\n        };\n      }\n    }\n\n    return {\n      value,\n      errors: typeof value === 'symbol' ? null : this.createError('symbol.base', {\n        value\n      }, state, options)\n    };\n  }\n\n  map(iterable) {\n    if (iterable && !iterable[Symbol.iterator] && typeof iterable === 'object') {\n      iterable = Object.entries(iterable);\n    }\n\n    Hoek.assert(iterable && iterable[Symbol.iterator], 'Iterable must be an iterable or object');\n    const obj = this.clone();\n    const symbols = [];\n\n    for (const entry of iterable) {\n      Hoek.assert(entry && entry[Symbol.iterator], 'Entry must be an iterable');\n      const [key, value] = entry;\n      Hoek.assert(typeof key !== 'object' && typeof key !== 'function' && typeof key !== 'symbol', 'Key must not be an object, function, or Symbol');\n      Hoek.assert(typeof value === 'symbol', 'Value must be a Symbol');\n\n      obj._inner.map.set(key, value);\n\n      symbols.push(value);\n    }\n\n    return obj.valid(...symbols);\n  }\n\n  describe() {\n    const description = super.describe();\n    description.map = new Map(this._inner.map);\n    return description;\n  }\n\n};\nmodule.exports = new internals.Symbol();","map":{"version":3,"sources":["C:/Users/Asus A455L/portfolio-rizky/portfolio2/client/node_modules/@hapi/joi/lib/types/symbol/index.js"],"names":["Util","require","Hoek","Any","internals","Map","slice","toString","inspect","Symbol","constructor","_type","_inner","map","_base","value","state","options","convert","lookup","get","_flags","allowOnly","errors","createError","iterable","iterator","Object","entries","assert","obj","clone","symbols","entry","key","set","push","valid","describe","description","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst Util = require('util');\n\nconst Hoek = require('@hapi/hoek');\n\nconst Any = require('../any');\n\n\nconst internals = {};\n\n\ninternals.Map = class extends Map {\n\n    slice() {\n\n        return new internals.Map(this);\n    }\n\n    toString() {\n\n        return Util.inspect(this);\n    }\n};\n\n\ninternals.Symbol = class extends Any {\n\n    constructor() {\n\n        super();\n        this._type = 'symbol';\n        this._inner.map = new internals.Map();\n    }\n\n    _base(value, state, options) {\n\n        if (options.convert) {\n            const lookup = this._inner.map.get(value);\n            if (lookup) {\n                value = lookup;\n            }\n\n            if (this._flags.allowOnly) {\n                return {\n                    value,\n                    errors: (typeof value === 'symbol') ? null : this.createError('symbol.map', { value, map: this._inner.map }, state, options)\n                };\n            }\n        }\n\n        return {\n            value,\n            errors: (typeof value === 'symbol') ? null : this.createError('symbol.base', { value }, state, options)\n        };\n    }\n\n    map(iterable) {\n\n        if (iterable && !iterable[Symbol.iterator] && typeof iterable === 'object') {\n            iterable = Object.entries(iterable);\n        }\n\n        Hoek.assert(iterable && iterable[Symbol.iterator], 'Iterable must be an iterable or object');\n        const obj = this.clone();\n\n        const symbols = [];\n        for (const entry of iterable) {\n            Hoek.assert(entry && entry[Symbol.iterator], 'Entry must be an iterable');\n            const [key, value] = entry;\n\n            Hoek.assert(typeof key !== 'object' && typeof key !== 'function' && typeof key !== 'symbol', 'Key must not be an object, function, or Symbol');\n            Hoek.assert(typeof value === 'symbol', 'Value must be a Symbol');\n            obj._inner.map.set(key, value);\n            symbols.push(value);\n        }\n\n        return obj.valid(...symbols);\n    }\n\n    describe() {\n\n        const description = super.describe();\n        description.map = new Map(this._inner.map);\n        return description;\n    }\n};\n\n\nmodule.exports = new internals.Symbol();\n"]},"metadata":{},"sourceType":"script"}