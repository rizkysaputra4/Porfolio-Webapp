{"ast":null,"code":"'use strict';\n\nconst Assert = require('@hapi/hoek/lib/assert');\n\nconst internals = {};\nmodule.exports = class Topo {\n  constructor() {\n    this._items = [];\n    this.nodes = [];\n  }\n\n  add(nodes, options) {\n    options = options || {}; // Validate rules\n\n    const before = [].concat(options.before || []);\n    const after = [].concat(options.after || []);\n    const group = options.group || '?';\n    const sort = options.sort || 0; // Used for merging only\n\n    Assert(!before.includes(group), `Item cannot come before itself: ${group}`);\n    Assert(!before.includes('?'), 'Item cannot come before unassociated items');\n    Assert(!after.includes(group), `Item cannot come after itself: ${group}`);\n    Assert(!after.includes('?'), 'Item cannot come after unassociated items');\n\n    if (!Array.isArray(nodes)) {\n      nodes = [nodes];\n    }\n\n    for (const node of nodes) {\n      const item = {\n        seq: this._items.length,\n        sort,\n        before,\n        after,\n        group,\n        node\n      };\n\n      this._items.push(item);\n    } // Insert event\n\n\n    const valid = this._sort();\n\n    Assert(valid, 'item', group !== '?' ? `added into group ${group}` : '', 'created a dependencies error');\n    return this.nodes;\n  }\n\n  merge(others) {\n    if (!Array.isArray(others)) {\n      others = [others];\n    }\n\n    for (const other of others) {\n      if (other) {\n        for (const item of other._items) {\n          this._items.push(Object.assign({}, item)); // Shallow cloned\n\n        }\n      }\n    } // Sort items\n\n\n    this._items.sort(internals.mergeSort);\n\n    for (let i = 0; i < this._items.length; ++i) {\n      this._items[i].seq = i;\n    }\n\n    const valid = this._sort();\n\n    Assert(valid, 'merge created a dependencies error');\n    return this.nodes;\n  }\n\n  _sort() {\n    // Construct graph\n    const graph = {};\n    const graphAfters = Object.create(null); // A prototype can bungle lookups w/ false positives\n\n    const groups = Object.create(null);\n\n    for (const item of this._items) {\n      const seq = item.seq; // Unique across all items\n\n      const group = item.group; // Determine Groups\n\n      groups[group] = groups[group] || [];\n      groups[group].push(seq); // Build intermediary graph using 'before'\n\n      graph[seq] = item.before; // Build second intermediary graph with 'after'\n\n      for (const after of item.after) {\n        graphAfters[after] = graphAfters[after] || [];\n        graphAfters[after].push(seq);\n      }\n    } // Expand intermediary graph\n\n\n    for (const node in graph) {\n      const expandedGroups = [];\n\n      for (const graphNodeItem in graph[node]) {\n        const group = graph[node][graphNodeItem];\n        groups[group] = groups[group] || [];\n        expandedGroups.push(...groups[group]);\n      }\n\n      graph[node] = expandedGroups;\n    } // Merge intermediary graph using graphAfters into final graph\n\n\n    for (const group in graphAfters) {\n      if (groups[group]) {\n        for (const node of groups[group]) {\n          graph[node].push(...graphAfters[group]);\n        }\n      }\n    } // Compile ancestors\n\n\n    const ancestors = {};\n\n    for (const node in graph) {\n      const children = graph[node];\n\n      for (const child of children) {\n        ancestors[child] = ancestors[child] || [];\n        ancestors[child].push(node);\n      }\n    } // Topo sort\n\n\n    const visited = {};\n    const sorted = [];\n\n    for (let i = 0; i < this._items.length; ++i) {\n      // Looping through item.seq values out of order\n      let next = i;\n\n      if (ancestors[i]) {\n        next = null;\n\n        for (let j = 0; j < this._items.length; ++j) {\n          // As above, these are item.seq values\n          if (visited[j] === true) {\n            continue;\n          }\n\n          if (!ancestors[j]) {\n            ancestors[j] = [];\n          }\n\n          const shouldSeeCount = ancestors[j].length;\n          let seenCount = 0;\n\n          for (let k = 0; k < shouldSeeCount; ++k) {\n            if (visited[ancestors[j][k]]) {\n              ++seenCount;\n            }\n          }\n\n          if (seenCount === shouldSeeCount) {\n            next = j;\n            break;\n          }\n        }\n      }\n\n      if (next !== null) {\n        visited[next] = true;\n        sorted.push(next);\n      }\n    }\n\n    if (sorted.length !== this._items.length) {\n      return false;\n    }\n\n    const seqIndex = {};\n\n    for (const item of this._items) {\n      seqIndex[item.seq] = item;\n    }\n\n    this._items = [];\n    this.nodes = [];\n\n    for (const value of sorted) {\n      const sortedItem = seqIndex[value];\n      this.nodes.push(sortedItem.node);\n\n      this._items.push(sortedItem);\n    }\n\n    return true;\n  }\n\n};\n\ninternals.mergeSort = (a, b) => {\n  return a.sort === b.sort ? 0 : a.sort < b.sort ? -1 : 1;\n};","map":{"version":3,"sources":["C:/Users/Asus A455L/portfolio-rizky/portfolio2/client/node_modules/@hapi/topo/lib/index.js"],"names":["Assert","require","internals","module","exports","Topo","constructor","_items","nodes","add","options","before","concat","after","group","sort","includes","Array","isArray","node","item","seq","length","push","valid","_sort","merge","others","other","Object","assign","mergeSort","i","graph","graphAfters","create","groups","expandedGroups","graphNodeItem","ancestors","children","child","visited","sorted","next","j","shouldSeeCount","seenCount","k","seqIndex","value","sortedItem","a","b"],"mappings":"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","sourcesContent":["'use strict';\r\n\r\nconst Assert = require('@hapi/hoek/lib/assert');\r\n\r\n\r\nconst internals = {};\r\n\r\n\r\nmodule.exports = class Topo {\r\n\r\n    constructor() {\r\n\r\n        this._items = [];\r\n        this.nodes = [];\r\n    }\r\n\r\n    add(nodes, options) {\r\n\r\n        options = options || {};\r\n\r\n        // Validate rules\r\n\r\n        const before = [].concat(options.before || []);\r\n        const after = [].concat(options.after || []);\r\n        const group = options.group || '?';\r\n        const sort = options.sort || 0;                   // Used for merging only\r\n\r\n        Assert(!before.includes(group), `Item cannot come before itself: ${group}`);\r\n        Assert(!before.includes('?'), 'Item cannot come before unassociated items');\r\n        Assert(!after.includes(group), `Item cannot come after itself: ${group}`);\r\n        Assert(!after.includes('?'), 'Item cannot come after unassociated items');\r\n\r\n        if (!Array.isArray(nodes)) {\r\n            nodes = [nodes];\r\n        }\r\n\r\n        for (const node of nodes) {\r\n            const item = {\r\n                seq: this._items.length,\r\n                sort,\r\n                before,\r\n                after,\r\n                group,\r\n                node\r\n            };\r\n\r\n            this._items.push(item);\r\n        }\r\n\r\n        // Insert event\r\n\r\n        const valid = this._sort();\r\n        Assert(valid, 'item', group !== '?' ? `added into group ${group}` : '', 'created a dependencies error');\r\n\r\n        return this.nodes;\r\n    }\r\n\r\n    merge(others) {\r\n\r\n        if (!Array.isArray(others)) {\r\n            others = [others];\r\n        }\r\n\r\n        for (const other of others) {\r\n            if (other) {\r\n                for (const item of other._items) {\r\n                    this._items.push(Object.assign({}, item));      // Shallow cloned\r\n                }\r\n            }\r\n        }\r\n\r\n        // Sort items\r\n\r\n        this._items.sort(internals.mergeSort);\r\n        for (let i = 0; i < this._items.length; ++i) {\r\n            this._items[i].seq = i;\r\n        }\r\n\r\n        const valid = this._sort();\r\n        Assert(valid, 'merge created a dependencies error');\r\n\r\n        return this.nodes;\r\n    }\r\n\r\n    _sort() {\r\n\r\n        // Construct graph\r\n\r\n        const graph = {};\r\n        const graphAfters = Object.create(null);            // A prototype can bungle lookups w/ false positives\r\n        const groups = Object.create(null);\r\n\r\n        for (const item of this._items) {\r\n            const seq = item.seq;                           // Unique across all items\r\n            const group = item.group;\r\n\r\n            // Determine Groups\r\n\r\n            groups[group] = groups[group] || [];\r\n            groups[group].push(seq);\r\n\r\n            // Build intermediary graph using 'before'\r\n\r\n            graph[seq] = item.before;\r\n\r\n            // Build second intermediary graph with 'after'\r\n\r\n            for (const after of item.after) {\r\n                graphAfters[after] = graphAfters[after] || [];\r\n                graphAfters[after].push(seq);\r\n            }\r\n        }\r\n\r\n        // Expand intermediary graph\r\n\r\n        for (const node in graph) {\r\n            const expandedGroups = [];\r\n\r\n            for (const graphNodeItem in graph[node]) {\r\n                const group = graph[node][graphNodeItem];\r\n                groups[group] = groups[group] || [];\r\n                expandedGroups.push(...groups[group]);\r\n            }\r\n\r\n            graph[node] = expandedGroups;\r\n        }\r\n\r\n        // Merge intermediary graph using graphAfters into final graph\r\n\r\n        for (const group in graphAfters) {\r\n            if (groups[group]) {\r\n                for (const node of groups[group]) {\r\n                    graph[node].push(...graphAfters[group]);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Compile ancestors\r\n\r\n        const ancestors = {};\r\n        for (const node in graph) {\r\n            const children = graph[node];\r\n            for (const child of children) {\r\n                ancestors[child] = ancestors[child] || [];\r\n                ancestors[child].push(node);\r\n            }\r\n        }\r\n\r\n        // Topo sort\r\n\r\n        const visited = {};\r\n        const sorted = [];\r\n\r\n        for (let i = 0; i < this._items.length; ++i) {          // Looping through item.seq values out of order\r\n            let next = i;\r\n\r\n            if (ancestors[i]) {\r\n                next = null;\r\n                for (let j = 0; j < this._items.length; ++j) {  // As above, these are item.seq values\r\n                    if (visited[j] === true) {\r\n                        continue;\r\n                    }\r\n\r\n                    if (!ancestors[j]) {\r\n                        ancestors[j] = [];\r\n                    }\r\n\r\n                    const shouldSeeCount = ancestors[j].length;\r\n                    let seenCount = 0;\r\n                    for (let k = 0; k < shouldSeeCount; ++k) {\r\n                        if (visited[ancestors[j][k]]) {\r\n                            ++seenCount;\r\n                        }\r\n                    }\r\n\r\n                    if (seenCount === shouldSeeCount) {\r\n                        next = j;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (next !== null) {\r\n                visited[next] = true;\r\n                sorted.push(next);\r\n            }\r\n        }\r\n\r\n        if (sorted.length !== this._items.length) {\r\n            return false;\r\n        }\r\n\r\n        const seqIndex = {};\r\n        for (const item of this._items) {\r\n            seqIndex[item.seq] = item;\r\n        }\r\n\r\n        this._items = [];\r\n        this.nodes = [];\r\n\r\n        for (const value of sorted) {\r\n            const sortedItem = seqIndex[value];\r\n            this.nodes.push(sortedItem.node);\r\n            this._items.push(sortedItem);\r\n        }\r\n\r\n        return true;\r\n    }\r\n};\r\n\r\n\r\ninternals.mergeSort = (a, b) => {\r\n\r\n    return a.sort === b.sort ? 0 : (a.sort < b.sort ? -1 : 1);\r\n};\r\n"]},"metadata":{},"sourceType":"script"}