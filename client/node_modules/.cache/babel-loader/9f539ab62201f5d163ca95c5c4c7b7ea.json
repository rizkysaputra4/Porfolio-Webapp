{"ast":null,"code":"'use strict';\n\nconst Ref = require('./ref');\n\nconst internals = {};\n\ninternals.extendedCheckForValue = function (value, insensitive) {\n  const valueType = typeof value;\n\n  if (valueType === 'object') {\n    if (value instanceof Date) {\n      return item => {\n        return item instanceof Date && value.getTime() === item.getTime();\n      };\n    }\n\n    if (Buffer.isBuffer(value)) {\n      return item => {\n        return Buffer.isBuffer(item) && value.length === item.length && value.toString('binary') === item.toString('binary');\n      };\n    }\n  } else if (insensitive && valueType === 'string') {\n    const lowercaseValue = value.toLowerCase();\n    return item => {\n      return typeof item === 'string' && lowercaseValue === item.toLowerCase();\n    };\n  }\n\n  return null;\n};\n\nmodule.exports = class InternalSet {\n  constructor(from) {\n    this._set = new Set(from);\n    this._hasRef = false;\n  }\n\n  add(value, refs) {\n    const isRef = Ref.isRef(value);\n\n    if (!isRef && this.has(value, null, null, false)) {\n      return this;\n    }\n\n    if (refs !== undefined) {\n      // If it's a merge, we don't have any refs\n      Ref.push(refs, value);\n    }\n\n    this._set.add(value);\n\n    this._hasRef |= isRef;\n    return this;\n  }\n\n  merge(add, remove) {\n    for (const item of add._set) {\n      this.add(item);\n    }\n\n    for (const item of remove._set) {\n      this.remove(item);\n    }\n\n    return this;\n  }\n\n  remove(value) {\n    this._set.delete(value);\n\n    return this;\n  }\n\n  has(value, state, options, insensitive) {\n    return !!this.get(value, state, options, insensitive);\n  }\n\n  get(value, state, options, insensitive) {\n    if (!this._set.size) {\n      return false;\n    }\n\n    const hasValue = this._set.has(value);\n\n    if (hasValue) {\n      return {\n        value\n      };\n    }\n\n    const extendedCheck = internals.extendedCheckForValue(value, insensitive);\n\n    if (!extendedCheck) {\n      if (state && this._hasRef) {\n        for (let item of this._set) {\n          if (Ref.isRef(item)) {\n            item = [].concat(item(state.reference || state.parent, options));\n            const found = item.indexOf(value);\n\n            if (found >= 0) {\n              return {\n                value: item[found]\n              };\n            }\n          }\n        }\n      }\n\n      return false;\n    }\n\n    return this._has(value, state, options, extendedCheck);\n  }\n\n  _has(value, state, options, check) {\n    const checkRef = !!(state && this._hasRef);\n\n    const isReallyEqual = function (item) {\n      if (value === item) {\n        return true;\n      }\n\n      return check(item);\n    };\n\n    for (let item of this._set) {\n      if (checkRef && Ref.isRef(item)) {\n        // Only resolve references if there is a state, otherwise it's a merge\n        item = item(state.reference || state.parent, options);\n\n        if (Array.isArray(item)) {\n          const found = item.findIndex(isReallyEqual);\n\n          if (found >= 0) {\n            return {\n              value: item[found]\n            };\n          }\n\n          continue;\n        }\n      }\n\n      if (isReallyEqual(item)) {\n        return {\n          value: item\n        };\n      }\n    }\n\n    return false;\n  }\n\n  values(options) {\n    if (options && options.stripUndefined) {\n      const values = [];\n\n      for (const item of this._set) {\n        if (item !== undefined) {\n          values.push(item);\n        }\n      }\n\n      return values;\n    }\n\n    return Array.from(this._set);\n  }\n\n  slice() {\n    const set = new InternalSet(this._set);\n    set._hasRef = this._hasRef;\n    return set;\n  }\n\n  concat(source) {\n    const set = new InternalSet([...this._set, ...source._set]);\n    set._hasRef = !!(this._hasRef | source._hasRef);\n    return set;\n  }\n\n};","map":{"version":3,"sources":["C:/Users/Asus A455L/portfolio-rizky/portfolio2/client/node_modules/@hapi/joi/lib/set.js"],"names":["Ref","require","internals","extendedCheckForValue","value","insensitive","valueType","Date","item","getTime","Buffer","isBuffer","length","toString","lowercaseValue","toLowerCase","module","exports","InternalSet","constructor","from","_set","Set","_hasRef","add","refs","isRef","has","undefined","push","merge","remove","delete","state","options","get","size","hasValue","extendedCheck","concat","reference","parent","found","indexOf","_has","check","checkRef","isReallyEqual","Array","isArray","findIndex","values","stripUndefined","slice","set","source"],"mappings":"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","sourcesContent":["'use strict';\n\nconst Ref = require('./ref');\n\n\nconst internals = {};\n\n\ninternals.extendedCheckForValue = function (value, insensitive) {\n\n    const valueType = typeof value;\n\n    if (valueType === 'object') {\n        if (value instanceof Date) {\n            return (item) => {\n\n                return item instanceof Date && value.getTime() === item.getTime();\n            };\n        }\n\n        if (Buffer.isBuffer(value)) {\n            return (item) => {\n\n                return Buffer.isBuffer(item) && value.length === item.length && value.toString('binary') === item.toString('binary');\n            };\n        }\n    }\n    else if (insensitive && valueType === 'string') {\n        const lowercaseValue = value.toLowerCase();\n        return (item) => {\n\n            return typeof item === 'string' && lowercaseValue === item.toLowerCase();\n        };\n    }\n\n    return null;\n};\n\n\nmodule.exports = class InternalSet {\n\n    constructor(from) {\n\n        this._set = new Set(from);\n        this._hasRef = false;\n    }\n\n    add(value, refs) {\n\n        const isRef = Ref.isRef(value);\n        if (!isRef && this.has(value, null, null, false)) {\n\n            return this;\n        }\n\n        if (refs !== undefined) { // If it's a merge, we don't have any refs\n            Ref.push(refs, value);\n        }\n\n        this._set.add(value);\n\n        this._hasRef |= isRef;\n\n        return this;\n    }\n\n    merge(add, remove) {\n\n        for (const item of add._set) {\n            this.add(item);\n        }\n\n        for (const item of remove._set) {\n            this.remove(item);\n        }\n\n        return this;\n    }\n\n    remove(value) {\n\n        this._set.delete(value);\n        return this;\n    }\n\n    has(value, state, options, insensitive) {\n\n        return !!this.get(value, state, options, insensitive);\n    }\n\n    get(value, state, options, insensitive) {\n\n        if (!this._set.size) {\n            return false;\n        }\n\n        const hasValue = this._set.has(value);\n        if (hasValue) {\n            return { value };\n        }\n\n        const extendedCheck = internals.extendedCheckForValue(value, insensitive);\n        if (!extendedCheck) {\n            if (state && this._hasRef) {\n                for (let item of this._set) {\n                    if (Ref.isRef(item)) {\n                        item = [].concat(item(state.reference || state.parent, options));\n                        const found = item.indexOf(value);\n                        if (found >= 0) {\n                            return { value: item[found] };\n                        }\n                    }\n                }\n            }\n\n            return false;\n        }\n\n        return this._has(value, state, options, extendedCheck);\n    }\n\n    _has(value, state, options, check) {\n\n        const checkRef = !!(state && this._hasRef);\n\n        const isReallyEqual = function (item) {\n\n            if (value === item) {\n                return true;\n            }\n\n            return check(item);\n        };\n\n        for (let item of this._set) {\n            if (checkRef && Ref.isRef(item)) { // Only resolve references if there is a state, otherwise it's a merge\n                item = item(state.reference || state.parent, options);\n\n                if (Array.isArray(item)) {\n                    const found = item.findIndex(isReallyEqual);\n                    if (found >= 0) {\n                        return {\n                            value: item[found]\n                        };\n                    }\n\n                    continue;\n                }\n            }\n\n            if (isReallyEqual(item)) {\n                return {\n                    value: item\n                };\n            }\n        }\n\n        return false;\n    }\n\n    values(options) {\n\n        if (options && options.stripUndefined) {\n            const values = [];\n\n            for (const item of this._set) {\n                if (item !== undefined) {\n                    values.push(item);\n                }\n            }\n\n            return values;\n        }\n\n        return Array.from(this._set);\n    }\n\n    slice() {\n\n        const set = new InternalSet(this._set);\n        set._hasRef = this._hasRef;\n        return set;\n    }\n\n    concat(source) {\n\n        const set = new InternalSet([...this._set, ...source._set]);\n        set._hasRef = !!(this._hasRef | source._hasRef);\n        return set;\n    }\n};\n"]},"metadata":{},"sourceType":"script"}