{"ast":null,"code":"'use strict';\n\nconst Types = require('./types');\n\nconst Utils = require('./utils');\n\nconst internals = {\n  needsProtoHack: new Set([Types.set, Types.map, Types.weakSet, Types.weakMap])\n};\n\nmodule.exports = internals.clone = function (obj, options = {}, _seen = null) {\n  if (typeof obj !== 'object' || obj === null) {\n    return obj;\n  }\n\n  let clone = internals.clone;\n  let seen = _seen;\n\n  if (options.shallow) {\n    if (options.shallow !== true) {\n      return internals.cloneWithShallow(obj, options);\n    }\n\n    clone = value => value;\n  } else {\n    seen = seen || new Map();\n    const lookup = seen.get(obj);\n\n    if (lookup) {\n      return lookup;\n    }\n  } // Built-in object types\n\n\n  const baseProto = Types.getInternalProto(obj);\n\n  if (baseProto === Types.buffer) {\n    return Buffer && Buffer.from(obj); // $lab:coverage:ignore$\n  }\n\n  if (baseProto === Types.date) {\n    return new Date(obj.getTime());\n  }\n\n  if (baseProto === Types.regex) {\n    return new RegExp(obj);\n  } // Generic objects\n\n\n  const newObj = internals.base(obj, baseProto, options);\n\n  if (newObj === obj) {\n    return obj;\n  }\n\n  if (seen) {\n    seen.set(obj, newObj); // Set seen, since obj could recurse\n  }\n\n  if (baseProto === Types.set) {\n    for (const value of obj) {\n      newObj.add(clone(value, options, seen));\n    }\n  } else if (baseProto === Types.map) {\n    for (const [key, value] of obj) {\n      newObj.set(key, clone(value, options, seen));\n    }\n  }\n\n  const keys = Utils.keys(obj, options);\n\n  for (const key of keys) {\n    if (key === '__proto__') {\n      continue;\n    }\n\n    if (baseProto === Types.array && key === 'length') {\n      newObj.length = obj.length;\n      continue;\n    }\n\n    const descriptor = Object.getOwnPropertyDescriptor(obj, key);\n\n    if (descriptor) {\n      if (descriptor.get || descriptor.set) {\n        Object.defineProperty(newObj, key, descriptor);\n      } else if (descriptor.enumerable) {\n        newObj[key] = clone(obj[key], options, seen);\n      } else {\n        Object.defineProperty(newObj, key, {\n          enumerable: false,\n          writable: true,\n          configurable: true,\n          value: clone(obj[key], options, seen)\n        });\n      }\n    } else {\n      Object.defineProperty(newObj, key, {\n        enumerable: true,\n        writable: true,\n        configurable: true,\n        value: clone(obj[key], options, seen)\n      });\n    }\n  }\n\n  return newObj;\n};\n\ninternals.cloneWithShallow = function (source, options) {\n  const keys = options.shallow;\n  options = Object.assign({}, options);\n  options.shallow = false;\n  const storage = Utils.store(source, keys); // Move shallow copy items to storage\n\n  const copy = internals.clone(source, options); // Deep copy the rest\n\n  Utils.restore(copy, source, storage); // Shallow copy the stored items and restore\n\n  return copy;\n};\n\ninternals.base = function (obj, baseProto, options) {\n  if (baseProto === Types.array) {\n    return [];\n  }\n\n  if (options.prototype === false) {\n    // Defaults to true\n    if (internals.needsProtoHack.has(baseProto)) {\n      return new baseProto.constructor();\n    }\n\n    return {};\n  }\n\n  const proto = Object.getPrototypeOf(obj);\n\n  if (proto && proto.isImmutable) {\n    return obj;\n  }\n\n  if (internals.needsProtoHack.has(baseProto)) {\n    const newObj = new proto.constructor();\n\n    if (proto !== baseProto) {\n      Object.setPrototypeOf(newObj, proto);\n    }\n\n    return newObj;\n  }\n\n  return Object.create(proto);\n};","map":{"version":3,"sources":["C:/Users/Asus A455L/portfolio-rizky/portfolio2/client/node_modules/@hapi/hoek/lib/clone.js"],"names":["Types","require","Utils","internals","needsProtoHack","Set","set","map","weakSet","weakMap","module","exports","clone","obj","options","_seen","seen","shallow","cloneWithShallow","value","Map","lookup","get","baseProto","getInternalProto","buffer","Buffer","from","date","Date","getTime","regex","RegExp","newObj","base","add","key","keys","array","length","descriptor","Object","getOwnPropertyDescriptor","defineProperty","enumerable","writable","configurable","source","assign","storage","store","copy","restore","prototype","has","constructor","proto","getPrototypeOf","isImmutable","setPrototypeOf","create"],"mappings":"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","sourcesContent":["'use strict';\n\nconst Types = require('./types');\nconst Utils = require('./utils');\n\n\nconst internals = {\n    needsProtoHack: new Set([Types.set, Types.map, Types.weakSet, Types.weakMap])\n};\n\n\nmodule.exports = internals.clone = function (obj, options = {}, _seen = null) {\n\n    if (typeof obj !== 'object' ||\n        obj === null) {\n\n        return obj;\n    }\n\n    let clone = internals.clone;\n    let seen = _seen;\n\n    if (options.shallow) {\n        if (options.shallow !== true) {\n            return internals.cloneWithShallow(obj, options);\n        }\n\n        clone = (value) => value;\n    }\n    else {\n        seen = seen || new Map();\n\n        const lookup = seen.get(obj);\n        if (lookup) {\n            return lookup;\n        }\n    }\n\n    // Built-in object types\n\n    const baseProto = Types.getInternalProto(obj);\n    if (baseProto === Types.buffer) {\n        return Buffer && Buffer.from(obj);              // $lab:coverage:ignore$\n    }\n\n    if (baseProto === Types.date) {\n        return new Date(obj.getTime());\n    }\n\n    if (baseProto === Types.regex) {\n        return new RegExp(obj);\n    }\n\n    // Generic objects\n\n    const newObj = internals.base(obj, baseProto, options);\n    if (newObj === obj) {\n        return obj;\n    }\n\n    if (seen) {\n        seen.set(obj, newObj);                              // Set seen, since obj could recurse\n    }\n\n    if (baseProto === Types.set) {\n        for (const value of obj) {\n            newObj.add(clone(value, options, seen));\n        }\n    }\n    else if (baseProto === Types.map) {\n        for (const [key, value] of obj) {\n            newObj.set(key, clone(value, options, seen));\n        }\n    }\n\n    const keys = Utils.keys(obj, options);\n    for (const key of keys) {\n        if (key === '__proto__') {\n            continue;\n        }\n\n        if (baseProto === Types.array &&\n            key === 'length') {\n\n            newObj.length = obj.length;\n            continue;\n        }\n\n        const descriptor = Object.getOwnPropertyDescriptor(obj, key);\n        if (descriptor) {\n            if (descriptor.get ||\n                descriptor.set) {\n\n                Object.defineProperty(newObj, key, descriptor);\n            }\n            else if (descriptor.enumerable) {\n                newObj[key] = clone(obj[key], options, seen);\n            }\n            else {\n                Object.defineProperty(newObj, key, { enumerable: false, writable: true, configurable: true, value: clone(obj[key], options, seen) });\n            }\n        }\n        else {\n            Object.defineProperty(newObj, key, {\n                enumerable: true,\n                writable: true,\n                configurable: true,\n                value: clone(obj[key], options, seen)\n            });\n        }\n    }\n\n    return newObj;\n};\n\n\ninternals.cloneWithShallow = function (source, options) {\n\n    const keys = options.shallow;\n    options = Object.assign({}, options);\n    options.shallow = false;\n\n    const storage = Utils.store(source, keys);    // Move shallow copy items to storage\n    const copy = internals.clone(source, options);      // Deep copy the rest\n    Utils.restore(copy, source, storage);         // Shallow copy the stored items and restore\n    return copy;\n};\n\n\ninternals.base = function (obj, baseProto, options) {\n\n    if (baseProto === Types.array) {\n        return [];\n    }\n\n    if (options.prototype === false) {                  // Defaults to true\n        if (internals.needsProtoHack.has(baseProto)) {\n            return new baseProto.constructor();\n        }\n\n        return {};\n    }\n\n    const proto = Object.getPrototypeOf(obj);\n    if (proto &&\n        proto.isImmutable) {\n\n        return obj;\n    }\n\n    if (internals.needsProtoHack.has(baseProto)) {\n        const newObj = new proto.constructor();\n        if (proto !== baseProto) {\n            Object.setPrototypeOf(newObj, proto);\n        }\n\n        return newObj;\n    }\n\n    return Object.create(proto);\n};\n"]},"metadata":{},"sourceType":"script"}