{"ast":null,"code":"'use strict';\n\nconst Bourne = require('@hapi/bourne');\n\nconst Hoek = require('@hapi/hoek');\n\nconst Topo = require('@hapi/topo');\n\nconst Any = require('../any');\n\nconst Errors = require('../../errors');\n\nconst Cast = require('../../cast');\n\nconst State = require('../state');\n\nconst internals = {};\ninternals.Object = class extends Any {\n  constructor() {\n    super();\n    this._type = 'object';\n    this._inner.children = null;\n    this._inner.renames = [];\n    this._inner.dependencies = [];\n    this._inner.patterns = [];\n  }\n\n  _init(...args) {\n    return args.length ? this.keys(...args) : this;\n  }\n\n  _base(value, state, options) {\n    let target = value;\n    const errors = [];\n\n    const finish = () => {\n      return {\n        value: target,\n        errors: errors.length ? errors : null\n      };\n    };\n\n    if (typeof value === 'string' && options.convert) {\n      if (value.length > 1 && (value[0] === '{' || /^\\s*\\{/.test(value))) {\n        try {\n          value = Bourne.parse(value);\n        } catch (e) {}\n      }\n    }\n\n    const type = this._flags.func ? 'function' : 'object';\n\n    if (!value || typeof value !== type || Array.isArray(value)) {\n      errors.push(this.createError(type + '.base', {\n        value\n      }, state, options));\n      return finish();\n    } // Skip if there are no other rules to test\n\n\n    if (!this._inner.renames.length && !this._inner.dependencies.length && !this._inner.children && // null allows any keys\n    !this._inner.patterns.length) {\n      target = value;\n      return finish();\n    } // Ensure target is a local copy (parsed) or shallow copy\n\n\n    if (target === value) {\n      if (type === 'object') {\n        target = Object.create(Object.getPrototypeOf(value));\n      } else {\n        target = function (...args) {\n          return value.apply(this, args);\n        };\n\n        target.prototype = Hoek.clone(value.prototype);\n      }\n\n      const valueKeys = Object.keys(value);\n\n      for (let i = 0; i < valueKeys.length; ++i) {\n        target[valueKeys[i]] = value[valueKeys[i]];\n      }\n    } else {\n      target = value;\n    } // Rename keys\n\n\n    const renamed = {};\n\n    for (let i = 0; i < this._inner.renames.length; ++i) {\n      const rename = this._inner.renames[i];\n\n      if (rename.isRegExp) {\n        const targetKeys = Object.keys(target);\n        const matchedTargetKeys = [];\n\n        for (let j = 0; j < targetKeys.length; ++j) {\n          if (rename.from.test(targetKeys[j])) {\n            matchedTargetKeys.push(targetKeys[j]);\n          }\n        }\n\n        const allUndefined = matchedTargetKeys.every(key => target[key] === undefined);\n\n        if (rename.options.ignoreUndefined && allUndefined) {\n          continue;\n        }\n\n        if (!rename.options.multiple && renamed[rename.to]) {\n          errors.push(this.createError('object.rename.regex.multiple', {\n            from: matchedTargetKeys,\n            to: rename.to\n          }, state, options));\n\n          if (options.abortEarly) {\n            return finish();\n          }\n        }\n\n        if (Object.prototype.hasOwnProperty.call(target, rename.to) && !rename.options.override && !renamed[rename.to]) {\n          errors.push(this.createError('object.rename.regex.override', {\n            from: matchedTargetKeys,\n            to: rename.to\n          }, state, options));\n\n          if (options.abortEarly) {\n            return finish();\n          }\n        }\n\n        if (allUndefined) {\n          delete target[rename.to];\n        } else {\n          target[rename.to] = target[matchedTargetKeys[matchedTargetKeys.length - 1]];\n        }\n\n        renamed[rename.to] = true;\n\n        if (!rename.options.alias) {\n          for (let j = 0; j < matchedTargetKeys.length; ++j) {\n            delete target[matchedTargetKeys[j]];\n          }\n        }\n      } else {\n        if (rename.options.ignoreUndefined && target[rename.from] === undefined) {\n          continue;\n        }\n\n        if (!rename.options.multiple && renamed[rename.to]) {\n          errors.push(this.createError('object.rename.multiple', {\n            from: rename.from,\n            to: rename.to\n          }, state, options));\n\n          if (options.abortEarly) {\n            return finish();\n          }\n        }\n\n        if (Object.prototype.hasOwnProperty.call(target, rename.to) && !rename.options.override && !renamed[rename.to]) {\n          errors.push(this.createError('object.rename.override', {\n            from: rename.from,\n            to: rename.to\n          }, state, options));\n\n          if (options.abortEarly) {\n            return finish();\n          }\n        }\n\n        if (target[rename.from] === undefined) {\n          delete target[rename.to];\n        } else {\n          target[rename.to] = target[rename.from];\n        }\n\n        renamed[rename.to] = true;\n\n        if (!rename.options.alias) {\n          delete target[rename.from];\n        }\n      }\n    } // Validate schema\n\n\n    if (!this._inner.children && // null allows any keys\n    !this._inner.patterns.length && !this._inner.dependencies.length) {\n      return finish();\n    }\n\n    const unprocessed = new Set(Object.keys(target));\n\n    if (this._inner.children) {\n      const stripProps = [];\n\n      for (let i = 0; i < this._inner.children.length; ++i) {\n        const child = this._inner.children[i];\n        const key = child.key;\n        const item = target[key];\n        unprocessed.delete(key);\n        const localState = new State(key, [...state.path, key], target, state.reference);\n\n        const result = child.schema._validate(item, localState, options);\n\n        if (result.errors) {\n          errors.push(this.createError('object.child', {\n            key,\n            child: child.schema._getLabel(key),\n            reason: result.errors\n          }, localState, options));\n\n          if (options.abortEarly) {\n            return finish();\n          }\n        } else {\n          if (child.schema._flags.strip || result.value === undefined && result.value !== item) {\n            stripProps.push(key);\n            target[key] = result.finalValue;\n          } else if (result.value !== undefined) {\n            target[key] = result.value;\n          }\n        }\n      }\n\n      for (let i = 0; i < stripProps.length; ++i) {\n        delete target[stripProps[i]];\n      }\n    } // Unknown keys\n\n\n    if (unprocessed.size && this._inner.patterns.length) {\n      for (const key of unprocessed) {\n        const localState = new State(key, [...state.path, key], target, state.reference);\n        const item = target[key];\n\n        for (let i = 0; i < this._inner.patterns.length; ++i) {\n          const pattern = this._inner.patterns[i];\n\n          if (pattern.regex ? pattern.regex.test(key) : !pattern.schema._validate(key, state, { ...options,\n            abortEarly: true\n          }).errors) {\n            unprocessed.delete(key);\n\n            const result = pattern.rule._validate(item, localState, options);\n\n            if (result.errors) {\n              errors.push(this.createError('object.child', {\n                key,\n                child: pattern.rule._getLabel(key),\n                reason: result.errors\n              }, localState, options));\n\n              if (options.abortEarly) {\n                return finish();\n              }\n            }\n\n            target[key] = result.value;\n          }\n        }\n      }\n    }\n\n    if (unprocessed.size && (this._inner.children || this._inner.patterns.length)) {\n      if (options.stripUnknown && this._flags.allowUnknown !== true || options.skipFunctions) {\n        const stripUnknown = options.stripUnknown ? options.stripUnknown === true ? true : !!options.stripUnknown.objects : false;\n\n        for (const key of unprocessed) {\n          if (stripUnknown) {\n            delete target[key];\n            unprocessed.delete(key);\n          } else if (typeof target[key] === 'function') {\n            unprocessed.delete(key);\n          }\n        }\n      }\n\n      if (this._flags.allowUnknown !== undefined ? !this._flags.allowUnknown : !options.allowUnknown) {\n        for (const unprocessedKey of unprocessed) {\n          errors.push(this.createError('object.allowUnknown', {\n            child: unprocessedKey,\n            value: target[unprocessedKey]\n          }, {\n            key: unprocessedKey,\n            path: [...state.path, unprocessedKey]\n          }, options, {}));\n        }\n      }\n    } // Validate dependencies\n\n\n    for (let i = 0; i < this._inner.dependencies.length; ++i) {\n      const dep = this._inner.dependencies[i];\n      const hasKey = dep.key !== null;\n      const splitKey = hasKey && dep.key.split('.');\n      const localState = hasKey ? new State(splitKey[splitKey.length - 1], [...state.path, ...splitKey]) : new State(null, state.path);\n      const err = internals[dep.type].call(this, dep.key, hasKey && Hoek.reach(target, dep.key, {\n        functions: true\n      }), dep.peers, target, localState, options);\n\n      if (err instanceof Errors.Err) {\n        errors.push(err);\n\n        if (options.abortEarly) {\n          return finish();\n        }\n      }\n    }\n\n    return finish();\n  }\n\n  keys(schema) {\n    Hoek.assert(schema === null || schema === undefined || typeof schema === 'object', 'Object schema must be a valid object');\n    Hoek.assert(!schema || !(schema instanceof Any), 'Object schema cannot be a joi schema');\n    const obj = this.clone();\n\n    if (!schema) {\n      obj._inner.children = null;\n      return obj;\n    }\n\n    const children = Object.keys(schema);\n\n    if (!children.length) {\n      obj._inner.children = [];\n      return obj;\n    }\n\n    const topo = new Topo();\n\n    if (obj._inner.children) {\n      for (let i = 0; i < obj._inner.children.length; ++i) {\n        const child = obj._inner.children[i]; // Only add the key if we are not going to replace it later\n\n        if (!children.includes(child.key)) {\n          topo.add(child, {\n            after: child._refs,\n            group: child.key\n          });\n        }\n      }\n    }\n\n    for (let i = 0; i < children.length; ++i) {\n      const key = children[i];\n      const child = schema[key];\n\n      try {\n        const cast = Cast.schema(this._currentJoi, child);\n        topo.add({\n          key,\n          schema: cast\n        }, {\n          after: cast._refs,\n          group: key\n        });\n      } catch (castErr) {\n        if (castErr.hasOwnProperty('path')) {\n          castErr.path = key + '.' + castErr.path;\n        } else {\n          castErr.path = key;\n        }\n\n        throw castErr;\n      }\n    }\n\n    obj._inner.children = topo.nodes;\n    return obj;\n  }\n\n  append(schema) {\n    // Skip any changes\n    if (schema === null || schema === undefined || Object.keys(schema).length === 0) {\n      return this;\n    }\n\n    return this.keys(schema);\n  }\n\n  unknown(allow) {\n    const value = allow !== false;\n\n    if (this._flags.allowUnknown === value) {\n      return this;\n    }\n\n    const obj = this.clone();\n    obj._flags.allowUnknown = value;\n    return obj;\n  }\n\n  length(limit) {\n    Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\n    return this._test('length', limit, function (value, state, options) {\n      if (Object.keys(value).length === limit) {\n        return value;\n      }\n\n      return this.createError('object.length', {\n        limit,\n        value\n      }, state, options);\n    });\n  }\n\n  min(limit) {\n    Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\n    return this._test('min', limit, function (value, state, options) {\n      if (Object.keys(value).length >= limit) {\n        return value;\n      }\n\n      return this.createError('object.min', {\n        limit,\n        value\n      }, state, options);\n    });\n  }\n\n  max(limit) {\n    Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\n    return this._test('max', limit, function (value, state, options) {\n      if (Object.keys(value).length <= limit) {\n        return value;\n      }\n\n      return this.createError('object.max', {\n        limit,\n        value\n      }, state, options);\n    });\n  }\n\n  pattern(pattern, schema) {\n    const isRegExp = pattern instanceof RegExp;\n    Hoek.assert(isRegExp || pattern instanceof Any, 'pattern must be a regex or schema');\n    Hoek.assert(schema !== undefined, 'Invalid rule');\n\n    if (isRegExp) {\n      Hoek.assert(!pattern.flags.includes('g') && !pattern.flags.includes('y'), 'pattern should not use global or sticky mode');\n    }\n\n    try {\n      schema = Cast.schema(this._currentJoi, schema);\n    } catch (castErr) {\n      if (castErr.hasOwnProperty('path')) {\n        castErr.message = `${castErr.message}(${castErr.path})`;\n      }\n\n      throw castErr;\n    }\n\n    const obj = this.clone();\n\n    if (isRegExp) {\n      obj._inner.patterns.push({\n        regex: pattern,\n        rule: schema\n      });\n    } else {\n      obj._inner.patterns.push({\n        schema: pattern,\n        rule: schema\n      });\n    }\n\n    return obj;\n  }\n\n  schema() {\n    return this._test('schema', null, function (value, state, options) {\n      if (value instanceof Any) {\n        return value;\n      }\n\n      return this.createError('object.schema', null, state, options);\n    });\n  }\n\n  with(key, peers) {\n    Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\n    return this._dependency('with', key, peers);\n  }\n\n  without(key, peers) {\n    Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\n    return this._dependency('without', key, peers);\n  }\n\n  xor(...peers) {\n    peers = Hoek.flatten(peers);\n    return this._dependency('xor', null, peers);\n  }\n\n  oxor(...peers) {\n    return this._dependency('oxor', null, peers);\n  }\n\n  or(...peers) {\n    peers = Hoek.flatten(peers);\n    return this._dependency('or', null, peers);\n  }\n\n  and(...peers) {\n    peers = Hoek.flatten(peers);\n    return this._dependency('and', null, peers);\n  }\n\n  nand(...peers) {\n    peers = Hoek.flatten(peers);\n    return this._dependency('nand', null, peers);\n  }\n\n  requiredKeys(...children) {\n    children = Hoek.flatten(children);\n    return this.applyFunctionToChildren(children, 'required');\n  }\n\n  optionalKeys(...children) {\n    children = Hoek.flatten(children);\n    return this.applyFunctionToChildren(children, 'optional');\n  }\n\n  forbiddenKeys(...children) {\n    children = Hoek.flatten(children);\n    return this.applyFunctionToChildren(children, 'forbidden');\n  }\n\n  rename(from, to, options) {\n    Hoek.assert(typeof from === 'string' || from instanceof RegExp, 'Rename missing the from argument');\n    Hoek.assert(typeof to === 'string', 'Rename missing the to argument');\n    Hoek.assert(to !== from, 'Cannot rename key to same name:', from);\n\n    for (let i = 0; i < this._inner.renames.length; ++i) {\n      Hoek.assert(this._inner.renames[i].from !== from, 'Cannot rename the same key multiple times');\n    }\n\n    const obj = this.clone();\n\n    obj._inner.renames.push({\n      from,\n      to,\n      options: Hoek.applyToDefaults(internals.renameDefaults, options || {}),\n      isRegExp: from instanceof RegExp\n    });\n\n    return obj;\n  }\n\n  applyFunctionToChildren(children, fn, args = [], root) {\n    children = [].concat(children);\n    Hoek.assert(children.length > 0, 'expected at least one children');\n    const groupedChildren = internals.groupChildren(children);\n    let obj;\n\n    if ('' in groupedChildren) {\n      obj = this[fn](...args);\n      delete groupedChildren[''];\n    } else {\n      obj = this.clone();\n    }\n\n    if (obj._inner.children) {\n      root = root ? root + '.' : '';\n\n      for (let i = 0; i < obj._inner.children.length; ++i) {\n        const child = obj._inner.children[i];\n        const group = groupedChildren[child.key];\n\n        if (group) {\n          obj._inner.children[i] = {\n            key: child.key,\n            _refs: child._refs,\n            schema: child.schema.applyFunctionToChildren(group, fn, args, root + child.key)\n          };\n          delete groupedChildren[child.key];\n        }\n      }\n    }\n\n    const remaining = Object.keys(groupedChildren);\n    Hoek.assert(remaining.length === 0, 'unknown key(s)', remaining.join(', '));\n    return obj;\n  }\n\n  _dependency(type, key, peers) {\n    peers = [].concat(peers);\n\n    for (let i = 0; i < peers.length; ++i) {\n      Hoek.assert(typeof peers[i] === 'string', type, 'peers must be a string or array of strings');\n    }\n\n    const obj = this.clone();\n\n    obj._inner.dependencies.push({\n      type,\n      key,\n      peers\n    });\n\n    return obj;\n  }\n\n  describe(shallow) {\n    const description = super.describe();\n\n    if (description.rules) {\n      for (let i = 0; i < description.rules.length; ++i) {\n        const rule = description.rules[i]; // Coverage off for future-proof descriptions, only object().assert() is use right now\n\n        if (\n        /* $lab:coverage:off$ */\n        rule.arg && typeof rule.arg === 'object' && rule.arg.schema && rule.arg.ref\n        /* $lab:coverage:on$ */\n        ) {\n            rule.arg = {\n              schema: rule.arg.schema.describe(),\n              ref: rule.arg.ref.toString()\n            };\n          }\n      }\n    }\n\n    if (this._inner.children && !shallow) {\n      description.children = {};\n\n      for (let i = 0; i < this._inner.children.length; ++i) {\n        const child = this._inner.children[i];\n        description.children[child.key] = child.schema.describe();\n      }\n    }\n\n    if (this._inner.dependencies.length) {\n      description.dependencies = Hoek.clone(this._inner.dependencies);\n    }\n\n    if (this._inner.patterns.length) {\n      description.patterns = [];\n\n      for (let i = 0; i < this._inner.patterns.length; ++i) {\n        const pattern = this._inner.patterns[i];\n\n        if (pattern.regex) {\n          description.patterns.push({\n            regex: pattern.regex.toString(),\n            rule: pattern.rule.describe()\n          });\n        } else {\n          description.patterns.push({\n            schema: pattern.schema.describe(),\n            rule: pattern.rule.describe()\n          });\n        }\n      }\n    }\n\n    if (this._inner.renames.length > 0) {\n      description.renames = Hoek.clone(this._inner.renames);\n    }\n\n    return description;\n  }\n\n  assert(ref, schema, message) {\n    ref = Cast.ref(ref);\n    Hoek.assert(ref.isContext || ref.depth > 1, 'Cannot use assertions for root level references - use direct key rules instead');\n    message = message || 'pass the assertion test';\n    Hoek.assert(typeof message === 'string', 'Message must be a string');\n\n    try {\n      schema = Cast.schema(this._currentJoi, schema);\n    } catch (castErr) {\n      if (castErr.hasOwnProperty('path')) {\n        castErr.message = `${castErr.message}(${castErr.path})`;\n      }\n\n      throw castErr;\n    }\n\n    const key = ref.path[ref.path.length - 1];\n    const path = ref.path.join('.');\n    return this._test('assert', {\n      schema,\n      ref\n    }, function (value, state, options) {\n      const result = schema._validate(ref(value), null, options, value);\n\n      if (!result.errors) {\n        return value;\n      }\n\n      const localState = new State(key, ref.path, state.parent, state.reference);\n      return this.createError('object.assert', {\n        ref: path,\n        message\n      }, localState, options);\n    });\n  }\n\n  type(constructor, name = constructor.name) {\n    Hoek.assert(typeof constructor === 'function', 'type must be a constructor function');\n    const typeData = {\n      name,\n      ctor: constructor\n    };\n    return this._test('type', typeData, function (value, state, options) {\n      if (value instanceof constructor) {\n        return value;\n      }\n\n      return this.createError('object.type', {\n        type: typeData.name,\n        value\n      }, state, options);\n    });\n  }\n\n};\ninternals.renameDefaults = {\n  alias: false,\n  // Keep old value in place\n  multiple: false,\n  // Allow renaming multiple keys into the same target\n  override: false // Overrides an existing key\n\n};\n\ninternals.groupChildren = function (children) {\n  children.sort();\n  const grouped = {};\n\n  for (let i = 0; i < children.length; ++i) {\n    const child = children[i];\n    Hoek.assert(typeof child === 'string', 'children must be strings');\n    const group = child.split('.')[0];\n    const childGroup = grouped[group] = grouped[group] || [];\n    childGroup.push(child.substring(group.length + 1));\n  }\n\n  return grouped;\n};\n\ninternals.keysToLabels = function (schema, keys) {\n  const children = schema._inner.children;\n\n  if (!children) {\n    return keys;\n  }\n\n  const findLabel = function (key) {\n    const matchingChild = schema._currentJoi.reach(schema, key);\n\n    return matchingChild ? matchingChild._getLabel(key) : key;\n  };\n\n  if (Array.isArray(keys)) {\n    return keys.map(findLabel);\n  }\n\n  return findLabel(keys);\n};\n\ninternals.with = function (key, value, peers, parent, state, options) {\n  if (value === undefined) {\n    return;\n  }\n\n  for (let i = 0; i < peers.length; ++i) {\n    const peer = peers[i];\n    const keysExist = Hoek.reach(parent, peer, {\n      functions: true\n    });\n\n    if (keysExist === undefined) {\n      return this.createError('object.with', {\n        main: key,\n        mainWithLabel: internals.keysToLabels(this, key),\n        peer,\n        peerWithLabel: internals.keysToLabels(this, peer)\n      }, state, options);\n    }\n  }\n};\n\ninternals.without = function (key, value, peers, parent, state, options) {\n  if (value === undefined) {\n    return;\n  }\n\n  for (let i = 0; i < peers.length; ++i) {\n    const peer = peers[i];\n    const keysExist = Hoek.reach(parent, peer, {\n      functions: true\n    });\n\n    if (keysExist !== undefined) {\n      return this.createError('object.without', {\n        main: key,\n        mainWithLabel: internals.keysToLabels(this, key),\n        peer,\n        peerWithLabel: internals.keysToLabels(this, peer)\n      }, state, options);\n    }\n  }\n};\n\ninternals.xor = function (key, value, peers, parent, state, options) {\n  const present = [];\n\n  for (let i = 0; i < peers.length; ++i) {\n    const peer = peers[i];\n    const keysExist = Hoek.reach(parent, peer, {\n      functions: true\n    });\n\n    if (keysExist !== undefined) {\n      present.push(peer);\n    }\n  }\n\n  if (present.length === 1) {\n    return;\n  }\n\n  const context = {\n    peers,\n    peersWithLabels: internals.keysToLabels(this, peers)\n  };\n\n  if (present.length === 0) {\n    return this.createError('object.missing', context, state, options);\n  }\n\n  context.present = present;\n  context.presentWithLabels = internals.keysToLabels(this, present);\n  return this.createError('object.xor', context, state, options);\n};\n\ninternals.oxor = function (key, value, peers, parent, state, options) {\n  const present = [];\n\n  for (let i = 0; i < peers.length; ++i) {\n    const peer = peers[i];\n    const keysExist = Hoek.reach(parent, peer, {\n      functions: true\n    });\n\n    if (keysExist !== undefined) {\n      present.push(peer);\n    }\n  }\n\n  if (!present.length || present.length === 1) {\n    return;\n  }\n\n  const context = {\n    peers,\n    peersWithLabels: internals.keysToLabels(this, peers)\n  };\n  context.present = present;\n  context.presentWithLabels = internals.keysToLabels(this, present);\n  return this.createError('object.oxor', context, state, options);\n};\n\ninternals.or = function (key, value, peers, parent, state, options) {\n  for (let i = 0; i < peers.length; ++i) {\n    const peer = peers[i];\n    const keysExist = Hoek.reach(parent, peer, {\n      functions: true\n    });\n\n    if (keysExist !== undefined) {\n      return;\n    }\n  }\n\n  return this.createError('object.missing', {\n    peers,\n    peersWithLabels: internals.keysToLabels(this, peers)\n  }, state, options);\n};\n\ninternals.and = function (key, value, peers, parent, state, options) {\n  const missing = [];\n  const present = [];\n  const count = peers.length;\n\n  for (let i = 0; i < count; ++i) {\n    const peer = peers[i];\n    const keysExist = Hoek.reach(parent, peer, {\n      functions: true\n    });\n\n    if (keysExist === undefined) {\n      missing.push(peer);\n    } else {\n      present.push(peer);\n    }\n  }\n\n  const aon = missing.length === count || present.length === count;\n\n  if (!aon) {\n    return this.createError('object.and', {\n      present,\n      presentWithLabels: internals.keysToLabels(this, present),\n      missing,\n      missingWithLabels: internals.keysToLabels(this, missing)\n    }, state, options);\n  }\n};\n\ninternals.nand = function (key, value, peers, parent, state, options) {\n  const present = [];\n\n  for (let i = 0; i < peers.length; ++i) {\n    const peer = peers[i];\n    const keysExist = Hoek.reach(parent, peer, {\n      functions: true\n    });\n\n    if (keysExist !== undefined) {\n      present.push(peer);\n    }\n  }\n\n  const main = peers[0];\n  const values = peers.slice(1);\n  const allPresent = present.length === peers.length;\n  return allPresent ? this.createError('object.nand', {\n    main,\n    mainWithLabel: internals.keysToLabels(this, main),\n    peers: values,\n    peersWithLabels: internals.keysToLabels(this, values)\n  }, state, options) : null;\n};\n\nmodule.exports = new internals.Object();","map":{"version":3,"sources":["C:/Users/Asus A455L/portfolio-rizky/portfolio2/client/node_modules/@hapi/joi/lib/types/object/index.js"],"names":["Bourne","require","Hoek","Topo","Any","Errors","Cast","State","internals","Object","constructor","_type","_inner","children","renames","dependencies","patterns","_init","args","length","keys","_base","value","state","options","target","errors","finish","convert","test","parse","e","type","_flags","func","Array","isArray","push","createError","create","getPrototypeOf","apply","prototype","clone","valueKeys","i","renamed","rename","isRegExp","targetKeys","matchedTargetKeys","j","from","allUndefined","every","key","undefined","ignoreUndefined","multiple","to","abortEarly","hasOwnProperty","call","override","alias","unprocessed","Set","stripProps","child","item","delete","localState","path","reference","result","schema","_validate","_getLabel","reason","strip","finalValue","size","pattern","regex","rule","stripUnknown","allowUnknown","skipFunctions","objects","unprocessedKey","dep","hasKey","splitKey","split","err","reach","functions","peers","Err","assert","obj","topo","includes","add","after","_refs","group","cast","_currentJoi","castErr","nodes","append","unknown","allow","limit","Number","isSafeInteger","_test","min","max","RegExp","flags","message","with","arguments","_dependency","without","xor","flatten","oxor","or","and","nand","requiredKeys","applyFunctionToChildren","optionalKeys","forbiddenKeys","applyToDefaults","renameDefaults","fn","root","concat","groupedChildren","groupChildren","remaining","join","describe","shallow","description","rules","arg","ref","toString","isContext","depth","parent","name","typeData","ctor","sort","grouped","childGroup","substring","keysToLabels","findLabel","matchingChild","map","peer","keysExist","main","mainWithLabel","peerWithLabel","present","context","peersWithLabels","presentWithLabels","missing","count","aon","missingWithLabels","values","slice","allPresent","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst Bourne = require('@hapi/bourne');\nconst Hoek = require('@hapi/hoek');\nconst Topo = require('@hapi/topo');\n\nconst Any = require('../any');\nconst Errors = require('../../errors');\nconst Cast = require('../../cast');\nconst State = require('../state');\n\n\nconst internals = {};\n\n\ninternals.Object = class extends Any {\n\n    constructor() {\n\n        super();\n        this._type = 'object';\n        this._inner.children = null;\n        this._inner.renames = [];\n        this._inner.dependencies = [];\n        this._inner.patterns = [];\n    }\n\n    _init(...args) {\n\n        return args.length ? this.keys(...args) : this;\n    }\n\n    _base(value, state, options) {\n\n        let target = value;\n        const errors = [];\n        const finish = () => {\n\n            return {\n                value: target,\n                errors: errors.length ? errors : null\n            };\n        };\n\n        if (typeof value === 'string' &&\n            options.convert) {\n\n            if (value.length > 1 &&\n                (value[0] === '{' || /^\\s*\\{/.test(value))) {\n\n                try {\n                    value = Bourne.parse(value);\n                }\n                catch (e) { }\n            }\n        }\n\n        const type = this._flags.func ? 'function' : 'object';\n        if (!value ||\n            typeof value !== type ||\n            Array.isArray(value)) {\n\n            errors.push(this.createError(type + '.base', { value }, state, options));\n            return finish();\n        }\n\n        // Skip if there are no other rules to test\n\n        if (!this._inner.renames.length &&\n            !this._inner.dependencies.length &&\n            !this._inner.children &&                    // null allows any keys\n            !this._inner.patterns.length) {\n\n            target = value;\n            return finish();\n        }\n\n        // Ensure target is a local copy (parsed) or shallow copy\n\n        if (target === value) {\n            if (type === 'object') {\n                target = Object.create(Object.getPrototypeOf(value));\n            }\n            else {\n                target = function (...args) {\n\n                    return value.apply(this, args);\n                };\n\n                target.prototype = Hoek.clone(value.prototype);\n            }\n\n            const valueKeys = Object.keys(value);\n            for (let i = 0; i < valueKeys.length; ++i) {\n                target[valueKeys[i]] = value[valueKeys[i]];\n            }\n        }\n        else {\n            target = value;\n        }\n\n        // Rename keys\n\n        const renamed = {};\n        for (let i = 0; i < this._inner.renames.length; ++i) {\n            const rename = this._inner.renames[i];\n\n            if (rename.isRegExp) {\n                const targetKeys = Object.keys(target);\n                const matchedTargetKeys = [];\n\n                for (let j = 0; j < targetKeys.length; ++j) {\n                    if (rename.from.test(targetKeys[j])) {\n                        matchedTargetKeys.push(targetKeys[j]);\n                    }\n                }\n\n                const allUndefined = matchedTargetKeys.every((key) => target[key] === undefined);\n                if (rename.options.ignoreUndefined && allUndefined) {\n                    continue;\n                }\n\n                if (!rename.options.multiple &&\n                    renamed[rename.to]) {\n\n                    errors.push(this.createError('object.rename.regex.multiple', { from: matchedTargetKeys, to: rename.to }, state, options));\n                    if (options.abortEarly) {\n                        return finish();\n                    }\n                }\n\n                if (Object.prototype.hasOwnProperty.call(target, rename.to) &&\n                    !rename.options.override &&\n                    !renamed[rename.to]) {\n\n                    errors.push(this.createError('object.rename.regex.override', { from: matchedTargetKeys, to: rename.to }, state, options));\n                    if (options.abortEarly) {\n                        return finish();\n                    }\n                }\n\n                if (allUndefined) {\n                    delete target[rename.to];\n                }\n                else {\n                    target[rename.to] = target[matchedTargetKeys[matchedTargetKeys.length - 1]];\n                }\n\n                renamed[rename.to] = true;\n\n                if (!rename.options.alias) {\n                    for (let j = 0; j < matchedTargetKeys.length; ++j) {\n                        delete target[matchedTargetKeys[j]];\n                    }\n                }\n            }\n            else {\n                if (rename.options.ignoreUndefined && target[rename.from] === undefined) {\n                    continue;\n                }\n\n                if (!rename.options.multiple &&\n                    renamed[rename.to]) {\n\n                    errors.push(this.createError('object.rename.multiple', { from: rename.from, to: rename.to }, state, options));\n                    if (options.abortEarly) {\n                        return finish();\n                    }\n                }\n\n                if (Object.prototype.hasOwnProperty.call(target, rename.to) &&\n                    !rename.options.override &&\n                    !renamed[rename.to]) {\n\n                    errors.push(this.createError('object.rename.override', { from: rename.from, to: rename.to }, state, options));\n                    if (options.abortEarly) {\n                        return finish();\n                    }\n                }\n\n                if (target[rename.from] === undefined) {\n                    delete target[rename.to];\n                }\n                else {\n                    target[rename.to] = target[rename.from];\n                }\n\n                renamed[rename.to] = true;\n\n                if (!rename.options.alias) {\n                    delete target[rename.from];\n                }\n            }\n        }\n\n        // Validate schema\n\n        if (!this._inner.children &&            // null allows any keys\n            !this._inner.patterns.length &&\n            !this._inner.dependencies.length) {\n\n            return finish();\n        }\n\n        const unprocessed = new Set(Object.keys(target));\n\n        if (this._inner.children) {\n            const stripProps = [];\n\n            for (let i = 0; i < this._inner.children.length; ++i) {\n                const child = this._inner.children[i];\n                const key = child.key;\n                const item = target[key];\n\n                unprocessed.delete(key);\n\n                const localState = new State(key, [...state.path, key], target, state.reference);\n                const result = child.schema._validate(item, localState, options);\n                if (result.errors) {\n                    errors.push(this.createError('object.child', { key, child: child.schema._getLabel(key), reason: result.errors }, localState, options));\n\n                    if (options.abortEarly) {\n                        return finish();\n                    }\n                }\n                else {\n                    if (child.schema._flags.strip || (result.value === undefined && result.value !== item)) {\n                        stripProps.push(key);\n                        target[key] = result.finalValue;\n                    }\n                    else if (result.value !== undefined) {\n                        target[key] = result.value;\n                    }\n                }\n            }\n\n            for (let i = 0; i < stripProps.length; ++i) {\n                delete target[stripProps[i]];\n            }\n        }\n\n        // Unknown keys\n\n        if (unprocessed.size && this._inner.patterns.length) {\n\n            for (const key of unprocessed) {\n                const localState = new State(key, [...state.path, key], target, state.reference);\n                const item = target[key];\n\n                for (let i = 0; i < this._inner.patterns.length; ++i) {\n                    const pattern = this._inner.patterns[i];\n\n                    if (pattern.regex ?\n                        pattern.regex.test(key) :\n                        !pattern.schema._validate(key, state, { ...options, abortEarly:true }).errors) {\n\n                        unprocessed.delete(key);\n\n                        const result = pattern.rule._validate(item, localState, options);\n                        if (result.errors) {\n                            errors.push(this.createError('object.child', {\n                                key,\n                                child: pattern.rule._getLabel(key),\n                                reason: result.errors\n                            }, localState, options));\n\n                            if (options.abortEarly) {\n                                return finish();\n                            }\n                        }\n\n                        target[key] = result.value;\n                    }\n                }\n            }\n        }\n\n        if (unprocessed.size && (this._inner.children || this._inner.patterns.length)) {\n            if ((options.stripUnknown && this._flags.allowUnknown !== true) ||\n                options.skipFunctions) {\n\n                const stripUnknown = options.stripUnknown\n                    ? (options.stripUnknown === true ? true : !!options.stripUnknown.objects)\n                    : false;\n\n\n                for (const key of unprocessed) {\n                    if (stripUnknown) {\n                        delete target[key];\n                        unprocessed.delete(key);\n                    }\n                    else if (typeof target[key] === 'function') {\n                        unprocessed.delete(key);\n                    }\n                }\n            }\n\n            if ((this._flags.allowUnknown !== undefined ? !this._flags.allowUnknown : !options.allowUnknown)) {\n\n                for (const unprocessedKey of unprocessed) {\n                    errors.push(this.createError('object.allowUnknown', { child: unprocessedKey, value: target[unprocessedKey] }, {\n                        key: unprocessedKey,\n                        path: [...state.path, unprocessedKey]\n                    }, options, {}));\n                }\n            }\n        }\n\n        // Validate dependencies\n\n        for (let i = 0; i < this._inner.dependencies.length; ++i) {\n            const dep = this._inner.dependencies[i];\n            const hasKey = dep.key !== null;\n            const splitKey = hasKey && dep.key.split('.');\n            const localState = hasKey ? new State(splitKey[splitKey.length - 1], [...state.path, ...splitKey]) : new State(null, state.path);\n            const err = internals[dep.type].call(this, dep.key, hasKey && Hoek.reach(target, dep.key, { functions: true }), dep.peers, target, localState, options);\n            if (err instanceof Errors.Err) {\n                errors.push(err);\n                if (options.abortEarly) {\n                    return finish();\n                }\n            }\n        }\n\n        return finish();\n    }\n\n    keys(schema) {\n\n        Hoek.assert(schema === null || schema === undefined || typeof schema === 'object', 'Object schema must be a valid object');\n        Hoek.assert(!schema || !(schema instanceof Any), 'Object schema cannot be a joi schema');\n\n        const obj = this.clone();\n\n        if (!schema) {\n            obj._inner.children = null;\n            return obj;\n        }\n\n        const children = Object.keys(schema);\n\n        if (!children.length) {\n            obj._inner.children = [];\n            return obj;\n        }\n\n        const topo = new Topo();\n        if (obj._inner.children) {\n            for (let i = 0; i < obj._inner.children.length; ++i) {\n                const child = obj._inner.children[i];\n\n                // Only add the key if we are not going to replace it later\n                if (!children.includes(child.key)) {\n                    topo.add(child, { after: child._refs, group: child.key });\n                }\n            }\n        }\n\n        for (let i = 0; i < children.length; ++i) {\n            const key = children[i];\n            const child = schema[key];\n            try {\n                const cast = Cast.schema(this._currentJoi, child);\n                topo.add({ key, schema: cast }, { after: cast._refs, group: key });\n            }\n            catch (castErr) {\n                if (castErr.hasOwnProperty('path')) {\n                    castErr.path = key + '.' + castErr.path;\n                }\n                else {\n                    castErr.path = key;\n                }\n\n                throw castErr;\n            }\n        }\n\n        obj._inner.children = topo.nodes;\n\n        return obj;\n    }\n\n    append(schema) {\n        // Skip any changes\n        if (schema === null || schema === undefined || Object.keys(schema).length === 0) {\n            return this;\n        }\n\n        return this.keys(schema);\n    }\n\n    unknown(allow) {\n\n        const value = allow !== false;\n\n        if (this._flags.allowUnknown === value) {\n            return this;\n        }\n\n        const obj = this.clone();\n        obj._flags.allowUnknown = value;\n        return obj;\n    }\n\n    length(limit) {\n\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\n\n        return this._test('length', limit, function (value, state, options) {\n\n            if (Object.keys(value).length === limit) {\n                return value;\n            }\n\n            return this.createError('object.length', { limit, value }, state, options);\n        });\n    }\n\n    min(limit) {\n\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\n\n        return this._test('min', limit, function (value, state, options) {\n\n            if (Object.keys(value).length >= limit) {\n                return value;\n            }\n\n            return this.createError('object.min', { limit, value }, state, options);\n        });\n    }\n\n    max(limit) {\n\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\n\n        return this._test('max', limit, function (value, state, options) {\n\n            if (Object.keys(value).length <= limit) {\n                return value;\n            }\n\n            return this.createError('object.max', { limit, value }, state, options);\n        });\n    }\n\n    pattern(pattern, schema) {\n\n        const isRegExp = pattern instanceof RegExp;\n        Hoek.assert(isRegExp || pattern instanceof Any, 'pattern must be a regex or schema');\n        Hoek.assert(schema !== undefined, 'Invalid rule');\n\n        if (isRegExp) {\n            Hoek.assert(!pattern.flags.includes('g') && !pattern.flags.includes('y'), 'pattern should not use global or sticky mode');\n        }\n\n        try {\n            schema = Cast.schema(this._currentJoi, schema);\n        }\n        catch (castErr) {\n            if (castErr.hasOwnProperty('path')) {\n                castErr.message = `${castErr.message}(${castErr.path})`;\n            }\n\n            throw castErr;\n        }\n\n        const obj = this.clone();\n        if (isRegExp) {\n            obj._inner.patterns.push({ regex: pattern, rule: schema });\n        }\n        else {\n            obj._inner.patterns.push({ schema: pattern, rule: schema });\n        }\n\n        return obj;\n    }\n\n    schema() {\n\n        return this._test('schema', null, function (value, state, options) {\n\n            if (value instanceof Any) {\n                return value;\n            }\n\n            return this.createError('object.schema', null, state, options);\n        });\n    }\n\n    with(key, peers) {\n\n        Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\n\n        return this._dependency('with', key, peers);\n    }\n\n    without(key, peers) {\n\n        Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\n\n        return this._dependency('without', key, peers);\n    }\n\n    xor(...peers) {\n\n        peers = Hoek.flatten(peers);\n        return this._dependency('xor', null, peers);\n    }\n\n    oxor(...peers) {\n\n        return this._dependency('oxor', null, peers);\n    }\n\n    or(...peers) {\n\n        peers = Hoek.flatten(peers);\n        return this._dependency('or', null, peers);\n    }\n\n    and(...peers) {\n\n        peers = Hoek.flatten(peers);\n        return this._dependency('and', null, peers);\n    }\n\n    nand(...peers) {\n\n        peers = Hoek.flatten(peers);\n        return this._dependency('nand', null, peers);\n    }\n\n    requiredKeys(...children) {\n\n        children = Hoek.flatten(children);\n        return this.applyFunctionToChildren(children, 'required');\n    }\n\n    optionalKeys(...children) {\n\n        children = Hoek.flatten(children);\n        return this.applyFunctionToChildren(children, 'optional');\n    }\n\n    forbiddenKeys(...children) {\n\n        children = Hoek.flatten(children);\n        return this.applyFunctionToChildren(children, 'forbidden');\n    }\n\n    rename(from, to, options) {\n\n        Hoek.assert(typeof from === 'string' || from instanceof RegExp, 'Rename missing the from argument');\n        Hoek.assert(typeof to === 'string', 'Rename missing the to argument');\n        Hoek.assert(to !== from, 'Cannot rename key to same name:', from);\n\n        for (let i = 0; i < this._inner.renames.length; ++i) {\n            Hoek.assert(this._inner.renames[i].from !== from, 'Cannot rename the same key multiple times');\n        }\n\n        const obj = this.clone();\n\n        obj._inner.renames.push({\n            from,\n            to,\n            options: Hoek.applyToDefaults(internals.renameDefaults, options || {}),\n            isRegExp: from instanceof RegExp\n        });\n\n        return obj;\n    }\n\n    applyFunctionToChildren(children, fn, args = [], root) {\n\n        children = [].concat(children);\n        Hoek.assert(children.length > 0, 'expected at least one children');\n\n        const groupedChildren = internals.groupChildren(children);\n        let obj;\n\n        if ('' in groupedChildren) {\n            obj = this[fn](...args);\n            delete groupedChildren[''];\n        }\n        else {\n            obj = this.clone();\n        }\n\n        if (obj._inner.children) {\n            root = root ? (root + '.') : '';\n\n            for (let i = 0; i < obj._inner.children.length; ++i) {\n                const child = obj._inner.children[i];\n                const group = groupedChildren[child.key];\n\n                if (group) {\n                    obj._inner.children[i] = {\n                        key: child.key,\n                        _refs: child._refs,\n                        schema: child.schema.applyFunctionToChildren(group, fn, args, root + child.key)\n                    };\n\n                    delete groupedChildren[child.key];\n                }\n            }\n        }\n\n        const remaining = Object.keys(groupedChildren);\n        Hoek.assert(remaining.length === 0, 'unknown key(s)', remaining.join(', '));\n\n        return obj;\n    }\n\n    _dependency(type, key, peers) {\n\n        peers = [].concat(peers);\n        for (let i = 0; i < peers.length; ++i) {\n            Hoek.assert(typeof peers[i] === 'string', type, 'peers must be a string or array of strings');\n        }\n\n        const obj = this.clone();\n        obj._inner.dependencies.push({ type, key, peers });\n        return obj;\n    }\n\n    describe(shallow) {\n\n        const description = super.describe();\n\n        if (description.rules) {\n            for (let i = 0; i < description.rules.length; ++i) {\n                const rule = description.rules[i];\n                // Coverage off for future-proof descriptions, only object().assert() is use right now\n                if (/* $lab:coverage:off$ */rule.arg &&\n                    typeof rule.arg === 'object' &&\n                    rule.arg.schema &&\n                    rule.arg.ref /* $lab:coverage:on$ */) {\n                    rule.arg = {\n                        schema: rule.arg.schema.describe(),\n                        ref: rule.arg.ref.toString()\n                    };\n                }\n            }\n        }\n\n        if (this._inner.children &&\n            !shallow) {\n\n            description.children = {};\n            for (let i = 0; i < this._inner.children.length; ++i) {\n                const child = this._inner.children[i];\n                description.children[child.key] = child.schema.describe();\n            }\n        }\n\n        if (this._inner.dependencies.length) {\n            description.dependencies = Hoek.clone(this._inner.dependencies);\n        }\n\n        if (this._inner.patterns.length) {\n            description.patterns = [];\n\n            for (let i = 0; i < this._inner.patterns.length; ++i) {\n                const pattern = this._inner.patterns[i];\n                if (pattern.regex) {\n                    description.patterns.push({ regex: pattern.regex.toString(), rule: pattern.rule.describe() });\n                }\n                else {\n                    description.patterns.push({ schema: pattern.schema.describe(), rule: pattern.rule.describe() });\n                }\n            }\n        }\n\n        if (this._inner.renames.length > 0) {\n            description.renames = Hoek.clone(this._inner.renames);\n        }\n\n        return description;\n    }\n\n    assert(ref, schema, message) {\n\n        ref = Cast.ref(ref);\n        Hoek.assert(ref.isContext || ref.depth > 1, 'Cannot use assertions for root level references - use direct key rules instead');\n        message = message || 'pass the assertion test';\n        Hoek.assert(typeof message === 'string', 'Message must be a string');\n\n        try {\n            schema = Cast.schema(this._currentJoi, schema);\n        }\n        catch (castErr) {\n            if (castErr.hasOwnProperty('path')) {\n                castErr.message = `${castErr.message}(${castErr.path})`;\n            }\n\n            throw castErr;\n        }\n\n        const key = ref.path[ref.path.length - 1];\n        const path = ref.path.join('.');\n\n        return this._test('assert', { schema, ref }, function (value, state, options) {\n\n            const result = schema._validate(ref(value), null, options, value);\n            if (!result.errors) {\n                return value;\n            }\n\n            const localState = new State(key, ref.path, state.parent, state.reference);\n            return this.createError('object.assert', { ref: path, message }, localState, options);\n        });\n    }\n\n    type(constructor, name = constructor.name) {\n\n        Hoek.assert(typeof constructor === 'function', 'type must be a constructor function');\n        const typeData = {\n            name,\n            ctor: constructor\n        };\n\n        return this._test('type', typeData, function (value, state, options) {\n\n            if (value instanceof constructor) {\n                return value;\n            }\n\n            return this.createError('object.type', { type: typeData.name, value }, state, options);\n        });\n    }\n};\n\n\ninternals.renameDefaults = {\n    alias: false,                   // Keep old value in place\n    multiple: false,                // Allow renaming multiple keys into the same target\n    override: false                 // Overrides an existing key\n};\n\n\ninternals.groupChildren = function (children) {\n\n    children.sort();\n\n    const grouped = {};\n\n    for (let i = 0; i < children.length; ++i) {\n        const child = children[i];\n        Hoek.assert(typeof child === 'string', 'children must be strings');\n        const group = child.split('.')[0];\n        const childGroup = grouped[group] = (grouped[group] || []);\n        childGroup.push(child.substring(group.length + 1));\n    }\n\n    return grouped;\n};\n\n\ninternals.keysToLabels = function (schema, keys) {\n\n    const children = schema._inner.children;\n\n    if (!children) {\n        return keys;\n    }\n\n    const findLabel = function (key) {\n\n        const matchingChild = schema._currentJoi.reach(schema, key);\n        return matchingChild ? matchingChild._getLabel(key) : key;\n    };\n\n    if (Array.isArray(keys)) {\n        return keys.map(findLabel);\n    }\n\n    return findLabel(keys);\n};\n\n\ninternals.with = function (key, value, peers, parent, state, options) {\n\n    if (value === undefined) {\n        return;\n    }\n\n    for (let i = 0; i < peers.length; ++i) {\n\n        const peer = peers[i];\n        const keysExist = Hoek.reach(parent, peer, { functions: true });\n        if (keysExist === undefined) {\n\n            return this.createError('object.with', {\n                main: key,\n                mainWithLabel: internals.keysToLabels(this, key),\n                peer,\n                peerWithLabel: internals.keysToLabels(this, peer)\n            }, state, options);\n        }\n    }\n};\n\n\ninternals.without = function (key, value, peers, parent, state, options) {\n\n    if (value === undefined) {\n        return;\n    }\n\n    for (let i = 0; i < peers.length; ++i) {\n        const peer = peers[i];\n        const keysExist = Hoek.reach(parent, peer, { functions: true });\n        if (keysExist !== undefined) {\n\n            return this.createError('object.without', {\n                main: key,\n                mainWithLabel: internals.keysToLabels(this, key),\n                peer,\n                peerWithLabel: internals.keysToLabels(this, peer)\n            }, state, options);\n        }\n    }\n};\n\n\ninternals.xor = function (key, value, peers, parent, state, options) {\n\n    const present = [];\n    for (let i = 0; i < peers.length; ++i) {\n        const peer = peers[i];\n        const keysExist = Hoek.reach(parent, peer, { functions: true });\n        if (keysExist !== undefined) {\n            present.push(peer);\n        }\n    }\n\n    if (present.length === 1) {\n        return;\n    }\n\n    const context = { peers, peersWithLabels: internals.keysToLabels(this, peers) };\n\n    if (present.length === 0) {\n        return this.createError('object.missing', context, state, options);\n    }\n\n    context.present = present;\n    context.presentWithLabels = internals.keysToLabels(this, present);\n\n    return this.createError('object.xor', context, state, options);\n};\n\n\ninternals.oxor = function (key, value, peers, parent, state, options) {\n\n    const present = [];\n    for (let i = 0; i < peers.length; ++i) {\n        const peer = peers[i];\n        const keysExist = Hoek.reach(parent, peer, { functions: true });\n        if (keysExist !== undefined) {\n            present.push(peer);\n        }\n    }\n\n    if (!present.length ||\n        present.length === 1) {\n\n        return;\n    }\n\n    const context = { peers, peersWithLabels: internals.keysToLabels(this, peers) };\n    context.present = present;\n    context.presentWithLabels = internals.keysToLabels(this, present);\n\n    return this.createError('object.oxor', context, state, options);\n};\n\n\ninternals.or = function (key, value, peers, parent, state, options) {\n\n    for (let i = 0; i < peers.length; ++i) {\n        const peer = peers[i];\n        const keysExist = Hoek.reach(parent, peer, { functions: true });\n        if (keysExist !== undefined) {\n            return;\n        }\n    }\n\n    return this.createError('object.missing', {\n        peers,\n        peersWithLabels: internals.keysToLabels(this, peers)\n    }, state, options);\n};\n\n\ninternals.and = function (key, value, peers, parent, state, options) {\n\n    const missing = [];\n    const present = [];\n    const count = peers.length;\n    for (let i = 0; i < count; ++i) {\n        const peer = peers[i];\n        const keysExist = Hoek.reach(parent, peer, { functions: true });\n        if (keysExist === undefined) {\n\n            missing.push(peer);\n        }\n        else {\n            present.push(peer);\n        }\n    }\n\n    const aon = (missing.length === count || present.length === count);\n\n    if (!aon) {\n\n        return this.createError('object.and', {\n            present,\n            presentWithLabels: internals.keysToLabels(this, present),\n            missing,\n            missingWithLabels: internals.keysToLabels(this, missing)\n        }, state, options);\n    }\n};\n\n\ninternals.nand = function (key, value, peers, parent, state, options) {\n\n    const present = [];\n    for (let i = 0; i < peers.length; ++i) {\n        const peer = peers[i];\n        const keysExist = Hoek.reach(parent, peer, { functions: true });\n        if (keysExist !== undefined) {\n\n            present.push(peer);\n        }\n    }\n\n    const main = peers[0];\n    const values = peers.slice(1);\n    const allPresent = (present.length === peers.length);\n    return allPresent ? this.createError('object.nand', {\n        main,\n        mainWithLabel: internals.keysToLabels(this, main),\n        peers: values,\n        peersWithLabels: internals.keysToLabels(this, values)\n    }, state, options) : null;\n};\n\n\nmodule.exports = new internals.Object();\n"]},"metadata":{},"sourceType":"script"}