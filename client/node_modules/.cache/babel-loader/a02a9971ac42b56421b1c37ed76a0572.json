{"ast":null,"code":"'use strict';\n\nconst Hoek = require('@hapi/hoek');\n\nconst Cast = require('../../cast');\n\nconst Settings = require('./settings');\n\nconst Ref = require('../../ref');\n\nconst Errors = require('../../errors');\n\nconst State = require('../state');\n\nconst Symbols = require('../symbols');\n\nconst Pkg = require('../../../package.json');\n\nlet Alternatives = null; // Delay-loaded to prevent circular dependencies\n\nlet Schemas = null;\nconst internals = {\n  Set: require('../../set'),\n  symbol: Symbol.for('@hapi/joi/schema')\n};\ninternals.defaults = {\n  abortEarly: true,\n  convert: true,\n  allowUnknown: false,\n  skipFunctions: false,\n  stripUnknown: false,\n  language: {},\n  presence: 'optional',\n  noDefaults: false,\n  escapeHtml: false // context: null\n\n};\nmodule.exports = internals.Any = class {\n  constructor() {\n    this.isJoi = true;\n    this._type = 'any';\n    this._settings = null;\n    this._valids = new internals.Set();\n    this._invalids = new internals.Set();\n    this._tests = [];\n    this._refs = [];\n    this._flags = {\n      /*\n       presence: 'optional',                   // optional, required, forbidden, ignore\n       allowOnly: false,\n       allowUnknown: undefined,\n       default: undefined,\n       forbidden: false,\n       encoding: undefined,\n       insensitive: false,\n       trim: false,\n       normalize: undefined,                   // NFC, NFD, NFKC, NFKD\n       case: undefined,                        // upper, lower\n       empty: undefined,\n       func: false,\n       raw: false\n       */\n    };\n    this._description = null;\n    this._unit = null;\n    this._notes = [];\n    this._tags = [];\n    this._examples = [];\n    this._meta = [];\n    this._inner = {}; // Hash of arrays of immutable objects\n  }\n\n  _init() {\n    return this;\n  }\n\n  get schemaType() {\n    return this._type;\n  }\n\n  createError(type, context, state, options, flags = this._flags) {\n    return Errors.create(type, context, state, options, flags);\n  }\n\n  createOverrideError(type, context, state, options, message, template) {\n    return Errors.create(type, context, state, options, this._flags, message, template);\n  }\n\n  checkOptions(options) {\n    Schemas = Schemas || require('../../schemas');\n    const result = Schemas.options.validate(options);\n\n    if (result.error) {\n      throw new Error(result.error.details[0].message);\n    }\n  }\n\n  clone() {\n    const obj = Object.create(Object.getPrototypeOf(this));\n    obj.isJoi = true;\n    obj._currentJoi = this._currentJoi;\n    obj._type = this._type;\n    obj._settings = this._settings;\n    obj._baseType = this._baseType;\n    obj._valids = this._valids.slice();\n    obj._invalids = this._invalids.slice();\n    obj._tests = this._tests.slice();\n    obj._refs = this._refs.slice();\n    obj._flags = Hoek.clone(this._flags);\n    obj._description = this._description;\n    obj._unit = this._unit;\n    obj._notes = this._notes.slice();\n    obj._tags = this._tags.slice();\n    obj._examples = this._examples.slice();\n    obj._meta = this._meta.slice();\n    obj._inner = {};\n    const inners = Object.keys(this._inner);\n\n    for (let i = 0; i < inners.length; ++i) {\n      const key = inners[i];\n      obj._inner[key] = this._inner[key] ? this._inner[key].slice() : null;\n    }\n\n    return obj;\n  }\n\n  concat(schema) {\n    Hoek.assert(schema instanceof internals.Any, 'Invalid schema object');\n    Hoek.assert(this._type === 'any' || schema._type === 'any' || schema._type === this._type, 'Cannot merge type', this._type, 'with another type:', schema._type);\n    let obj = this.clone();\n\n    if (this._type === 'any' && schema._type !== 'any') {\n      // Reset values as if we were \"this\"\n      const tmpObj = schema.clone();\n      const keysToRestore = ['_settings', '_valids', '_invalids', '_tests', '_refs', '_flags', '_description', '_unit', '_notes', '_tags', '_examples', '_meta', '_inner'];\n\n      for (let i = 0; i < keysToRestore.length; ++i) {\n        tmpObj[keysToRestore[i]] = obj[keysToRestore[i]];\n      }\n\n      obj = tmpObj;\n    }\n\n    obj._settings = obj._settings ? Settings.concat(obj._settings, schema._settings) : schema._settings;\n\n    obj._valids.merge(schema._valids, schema._invalids);\n\n    obj._invalids.merge(schema._invalids, schema._valids);\n\n    obj._tests.push(...schema._tests);\n\n    obj._refs.push(...schema._refs);\n\n    if (obj._flags.empty && schema._flags.empty) {\n      obj._flags.empty = obj._flags.empty.concat(schema._flags.empty);\n      const flags = Object.assign({}, schema._flags);\n      delete flags.empty;\n      Hoek.merge(obj._flags, flags);\n    } else if (schema._flags.empty) {\n      obj._flags.empty = schema._flags.empty;\n      const flags = Object.assign({}, schema._flags);\n      delete flags.empty;\n      Hoek.merge(obj._flags, flags);\n    } else {\n      Hoek.merge(obj._flags, schema._flags);\n    }\n\n    obj._description = schema._description || obj._description;\n    obj._unit = schema._unit || obj._unit;\n\n    obj._notes.push(...schema._notes);\n\n    obj._tags.push(...schema._tags);\n\n    obj._examples.push(...schema._examples);\n\n    obj._meta.push(...schema._meta);\n\n    const inners = Object.keys(schema._inner);\n    const isObject = obj._type === 'object';\n\n    for (let i = 0; i < inners.length; ++i) {\n      const key = inners[i];\n      const source = schema._inner[key];\n\n      if (source) {\n        const target = obj._inner[key];\n\n        if (target) {\n          if (isObject && key === 'children') {\n            const keys = {};\n\n            for (let j = 0; j < target.length; ++j) {\n              keys[target[j].key] = j;\n            }\n\n            for (let j = 0; j < source.length; ++j) {\n              const sourceKey = source[j].key;\n\n              if (keys[sourceKey] >= 0) {\n                target[keys[sourceKey]] = {\n                  key: sourceKey,\n                  schema: target[keys[sourceKey]].schema.concat(source[j].schema)\n                };\n              } else {\n                target.push(source[j]);\n              }\n            }\n          } else {\n            obj._inner[key] = obj._inner[key].concat(source);\n          }\n        } else {\n          obj._inner[key] = source.slice();\n        }\n      }\n    }\n\n    return obj;\n  }\n\n  _test(name, arg, func, options) {\n    const obj = this.clone();\n\n    obj._tests.push({\n      func,\n      name,\n      arg,\n      options\n    });\n\n    return obj;\n  }\n\n  _testUnique(name, arg, func, options) {\n    const obj = this.clone();\n    obj._tests = obj._tests.filter(test => test.name !== name);\n\n    obj._tests.push({\n      func,\n      name,\n      arg,\n      options\n    });\n\n    return obj;\n  }\n\n  options(options) {\n    Hoek.assert(!options.context, 'Cannot override context');\n    this.checkOptions(options);\n    const obj = this.clone();\n    obj._settings = Settings.concat(obj._settings, options);\n    return obj;\n  }\n\n  strict(isStrict) {\n    const obj = this.clone();\n    const convert = isStrict === undefined ? false : !isStrict;\n    obj._settings = Settings.concat(obj._settings, {\n      convert\n    });\n    return obj;\n  }\n\n  raw(isRaw) {\n    const value = isRaw === undefined ? true : isRaw;\n\n    if (this._flags.raw === value) {\n      return this;\n    }\n\n    const obj = this.clone();\n    obj._flags.raw = value;\n    return obj;\n  }\n\n  error(err, options = {\n    self: false\n  }) {\n    Hoek.assert(err && (err instanceof Error || typeof err === 'function'), 'Must provide a valid Error object or a function');\n    const unknownKeys = Object.keys(options).filter(k => !['self'].includes(k));\n    Hoek.assert(unknownKeys.length === 0, `Options ${unknownKeys} are unknown`);\n    const obj = this.clone();\n    obj._flags.error = err;\n\n    if (options.self) {\n      obj._flags.selfError = true;\n    }\n\n    return obj;\n  }\n\n  allow(...values) {\n    const obj = this.clone();\n    values = Hoek.flatten(values);\n\n    for (let i = 0; i < values.length; ++i) {\n      const value = values[i];\n      Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\n\n      obj._invalids.remove(value);\n\n      obj._valids.add(value, obj._refs);\n    }\n\n    return obj;\n  }\n\n  valid(...values) {\n    const obj = this.allow(...values);\n    obj._flags.allowOnly = true;\n    return obj;\n  }\n\n  invalid(...values) {\n    const obj = this.clone();\n    values = Hoek.flatten(values);\n\n    for (let i = 0; i < values.length; ++i) {\n      const value = values[i];\n      Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\n\n      obj._valids.remove(value);\n\n      obj._invalids.add(value, obj._refs);\n    }\n\n    return obj;\n  }\n\n  required() {\n    if (this._flags.presence === 'required') {\n      return this;\n    }\n\n    const obj = this.clone();\n    obj._flags.presence = 'required';\n    return obj;\n  }\n\n  optional() {\n    if (this._flags.presence === 'optional') {\n      return this;\n    }\n\n    const obj = this.clone();\n    obj._flags.presence = 'optional';\n    return obj;\n  }\n\n  forbidden() {\n    if (this._flags.presence === 'forbidden') {\n      return this;\n    }\n\n    const obj = this.clone();\n    obj._flags.presence = 'forbidden';\n    return obj;\n  }\n\n  strip() {\n    if (this._flags.strip) {\n      return this;\n    }\n\n    const obj = this.clone();\n    obj._flags.strip = true;\n    return obj;\n  }\n\n  applyFunctionToChildren(children, fn, args = [], root) {\n    children = [].concat(children);\n\n    if (children.length !== 1 || children[0] !== '') {\n      root = root ? root + '.' : '';\n      const extraChildren = (children[0] === '' ? children.slice(1) : children).map(child => {\n        return root + child;\n      });\n      throw new Error('unknown key(s) ' + extraChildren.join(', '));\n    }\n\n    return this[fn](...args);\n  }\n\n  default(value, description) {\n    if (typeof value === 'function' && !Ref.isRef(value)) {\n      if (!value.description && description) {\n        value.description = description;\n      }\n\n      if (!this._flags.func) {\n        Hoek.assert(typeof value.description === 'string' && value.description.length > 0, 'description must be provided when default value is a function');\n      }\n    }\n\n    const obj = this.clone();\n    obj._flags.default = value;\n    Ref.push(obj._refs, value);\n    return obj;\n  }\n\n  empty(schema) {\n    const obj = this.clone();\n\n    if (schema === undefined) {\n      delete obj._flags.empty;\n    } else {\n      obj._flags.empty = Cast.schema(this._currentJoi, schema);\n    }\n\n    return obj;\n  }\n\n  when(condition, options) {\n    Hoek.assert(options && typeof options === 'object', 'Invalid options');\n    Hoek.assert(options.then !== undefined || options.otherwise !== undefined, 'options must have at least one of \"then\" or \"otherwise\"');\n    const then = options.hasOwnProperty('then') ? this.concat(Cast.schema(this._currentJoi, options.then)) : undefined;\n    const otherwise = options.hasOwnProperty('otherwise') ? this.concat(Cast.schema(this._currentJoi, options.otherwise)) : undefined;\n    Alternatives = Alternatives || require('../alternatives');\n    const alternativeOptions = {\n      then,\n      otherwise\n    };\n\n    if (Object.prototype.hasOwnProperty.call(options, 'is')) {\n      alternativeOptions.is = options.is;\n    }\n\n    const obj = Alternatives.when(condition, alternativeOptions);\n    obj._flags.presence = 'ignore';\n    obj._baseType = this;\n    return obj;\n  }\n\n  description(desc) {\n    Hoek.assert(desc && typeof desc === 'string', 'Description must be a non-empty string');\n    const obj = this.clone();\n    obj._description = desc;\n    return obj;\n  }\n\n  notes(notes) {\n    Hoek.assert(notes && (typeof notes === 'string' || Array.isArray(notes)), 'Notes must be a non-empty string or array');\n    const obj = this.clone();\n    obj._notes = obj._notes.concat(notes);\n    return obj;\n  }\n\n  tags(tags) {\n    Hoek.assert(tags && (typeof tags === 'string' || Array.isArray(tags)), 'Tags must be a non-empty string or array');\n    const obj = this.clone();\n    obj._tags = obj._tags.concat(tags);\n    return obj;\n  }\n\n  meta(meta) {\n    Hoek.assert(meta !== undefined, 'Meta cannot be undefined');\n    const obj = this.clone();\n    obj._meta = obj._meta.concat(meta);\n    return obj;\n  }\n\n  example(...examples) {\n    Hoek.assert(examples.length > 0, 'Missing examples');\n    const processed = [];\n\n    for (let i = 0; i < examples.length; ++i) {\n      const example = [].concat(examples[i]);\n      Hoek.assert(example.length <= 2, `Bad example format at index ${i}`);\n      const value = example[0];\n      let options = example[1];\n\n      if (options !== undefined) {\n        Hoek.assert(options && typeof options === 'object', `Options for example at index ${i} must be an object`);\n        const unknownOptions = Object.keys(options).filter(option => !['parent', 'context'].includes(option));\n        Hoek.assert(unknownOptions.length === 0, `Unknown example options ${unknownOptions} at index ${i}`);\n      } else {\n        options = {};\n      }\n\n      const localState = new State('', [], options.parent || null);\n\n      const result = this._validate(value, localState, Settings.concat(internals.defaults, options.context ? {\n        context: options.context\n      } : null));\n\n      Hoek.assert(!result.errors, `Bad example at index ${i}:`, result.errors && Errors.process(result.errors, value));\n      const ex = {\n        value\n      };\n\n      if (Object.keys(options).length) {\n        ex.options = options;\n      }\n\n      processed.push(ex);\n    }\n\n    const obj = this.clone();\n    obj._examples = processed;\n    return obj;\n  }\n\n  unit(name) {\n    Hoek.assert(name && typeof name === 'string', 'Unit name must be a non-empty string');\n    const obj = this.clone();\n    obj._unit = name;\n    return obj;\n  }\n\n  _prepareEmptyValue(value) {\n    if (typeof value === 'string' && this._flags.trim) {\n      return value.trim();\n    }\n\n    return value;\n  }\n\n  _validate(value, state, options, reference) {\n    const originalValue = value; // Setup state and settings\n\n    state = state || new State('', [], null, reference);\n\n    if (this._settings) {\n      const isDefaultOptions = options === internals.defaults;\n\n      if (isDefaultOptions && this._settings[Symbols.settingsCache]) {\n        options = this._settings[Symbols.settingsCache];\n      } else {\n        options = Settings.concat(this._language ? Settings.concat({\n          language: this._language\n        }, options) : options, this._settings);\n\n        if (isDefaultOptions) {\n          this._settings[Symbols.settingsCache] = options;\n        }\n      }\n    } else if (this._language) {\n      options = Settings.concat({\n        language: this._language\n      }, options);\n    }\n\n    let errors = [];\n\n    if (this._coerce) {\n      const coerced = this._coerce(value, state, options);\n\n      if (coerced.errors) {\n        value = coerced.value;\n        errors = errors.concat(coerced.errors);\n        return this._finalizeValue(value, originalValue, errors, state, options); // Coerced error always aborts early\n      }\n\n      value = coerced.value;\n    }\n\n    if (this._flags.empty && !this._flags.empty._validate(this._prepareEmptyValue(value), null, internals.defaults).errors) {\n      value = undefined;\n    } // Check presence requirements\n\n\n    const presence = this._flags.presence || options.presence;\n\n    if (presence === 'optional') {\n      if (value === undefined) {\n        const isDeepDefault = this._flags.hasOwnProperty('default') && this._flags.default === undefined;\n\n        if (isDeepDefault && this._type === 'object') {\n          value = {};\n        } else {\n          return this._finalizeValue(value, originalValue, errors, state, options);\n        }\n      }\n    } else if (presence === 'required' && value === undefined) {\n      errors.push(this.createError('any.required', null, state, options));\n      return this._finalizeValue(value, originalValue, errors, state, options);\n    } else if (presence === 'forbidden') {\n      if (value === undefined) {\n        return this._finalizeValue(value, originalValue, errors, state, options);\n      }\n\n      errors.push(this.createError('any.unknown', null, state, options));\n      return this._finalizeValue(value, originalValue, errors, state, options);\n    } // Check allowed and denied values using the original value\n\n\n    let match = this._valids.get(value, state, options, this._flags.insensitive);\n\n    if (match) {\n      if (options.convert) {\n        value = match.value;\n      }\n\n      return this._finalizeValue(value, originalValue, errors, state, options);\n    }\n\n    if (this._invalids.has(value, state, options, this._flags.insensitive)) {\n      errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', {\n        value,\n        invalids: this._invalids.values({\n          stripUndefined: true\n        })\n      }, state, options));\n\n      if (options.abortEarly) {\n        return this._finalizeValue(value, originalValue, errors, state, options);\n      }\n    } // Convert value and validate type\n\n\n    if (this._base) {\n      const base = this._base(value, state, options);\n\n      if (base.errors) {\n        value = base.value;\n        errors = errors.concat(base.errors);\n        return this._finalizeValue(value, originalValue, errors, state, options); // Base error always aborts early\n      }\n\n      if (base.value !== value) {\n        value = base.value; // Check allowed and denied values using the converted value\n\n        match = this._valids.get(value, state, options, this._flags.insensitive);\n\n        if (match) {\n          value = match.value;\n          return this._finalizeValue(value, originalValue, errors, state, options);\n        }\n\n        if (this._invalids.has(value, state, options, this._flags.insensitive)) {\n          errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', {\n            value,\n            invalids: this._invalids.values({\n              stripUndefined: true\n            })\n          }, state, options));\n\n          if (options.abortEarly) {\n            return this._finalizeValue(value, originalValue, errors, state, options);\n          }\n        }\n      }\n    } // Required values did not match\n\n\n    if (this._flags.allowOnly) {\n      errors.push(this.createError('any.allowOnly', {\n        value,\n        valids: this._valids.values({\n          stripUndefined: true\n        })\n      }, state, options));\n\n      if (options.abortEarly) {\n        return this._finalizeValue(value, originalValue, errors, state, options);\n      }\n    } // Validate tests\n\n\n    for (let i = 0; i < this._tests.length; ++i) {\n      const test = this._tests[i];\n      const ret = test.func.call(this, value, state, options);\n\n      if (ret instanceof Errors.Err) {\n        errors.push(ret);\n\n        if (options.abortEarly) {\n          return this._finalizeValue(value, originalValue, errors, state, options);\n        }\n      } else {\n        value = ret;\n      }\n    }\n\n    return this._finalizeValue(value, originalValue, errors, state, options);\n  }\n\n  _finalizeValue(value, originalValue, errors, state, options) {\n    let finalValue;\n\n    if (value !== undefined) {\n      finalValue = this._flags.raw ? originalValue : value;\n    } else if (options.noDefaults) {\n      finalValue = value;\n    } else if (Ref.isRef(this._flags.default)) {\n      finalValue = this._flags.default(state.parent, options);\n    } else if (typeof this._flags.default === 'function' && !(this._flags.func && !this._flags.default.description)) {\n      let args;\n\n      if (state.parent !== null && this._flags.default.length > 0) {\n        args = [Hoek.clone(state.parent), options];\n      }\n\n      const defaultValue = internals._try(this._flags.default, args);\n\n      finalValue = defaultValue.value;\n\n      if (defaultValue.error) {\n        errors.push(this.createError('any.default', {\n          error: defaultValue.error\n        }, state, options));\n      }\n    } else {\n      finalValue = Hoek.clone(this._flags.default);\n    }\n\n    if (errors.length && typeof this._flags.error === 'function' && (!this._flags.selfError || errors.some(e => state.path.length === e.path.length))) {\n      const change = this._flags.error.call(this, errors);\n\n      if (typeof change === 'string') {\n        errors = [this.createOverrideError('override', {\n          reason: errors\n        }, state, options, change)];\n      } else {\n        errors = [].concat(change).map(err => {\n          return err instanceof Error ? err : this.createOverrideError(err.type || 'override', err.context, state, options, err.message, err.template);\n        });\n      }\n    }\n\n    return {\n      value: this._flags.strip ? undefined : finalValue,\n      finalValue,\n      errors: errors.length ? errors : null\n    };\n  }\n\n  _validateWithOptions(value, options, callback) {\n    if (options) {\n      this.checkOptions(options);\n    }\n\n    const settings = Settings.concat(internals.defaults, options);\n\n    const result = this._validate(value, null, settings);\n\n    const errors = Errors.process(result.errors, value);\n\n    if (callback) {\n      return callback(errors, result.value);\n    }\n\n    return {\n      error: errors,\n      value: result.value,\n\n      then(resolve, reject) {\n        if (errors) {\n          return Promise.reject(errors).catch(reject);\n        }\n\n        return Promise.resolve(result.value).then(resolve);\n      },\n\n      catch(reject) {\n        if (errors) {\n          return Promise.reject(errors).catch(reject);\n        }\n\n        return Promise.resolve(result.value);\n      }\n\n    };\n  }\n\n  validate(value, options, callback) {\n    if (typeof options === 'function') {\n      return this._validateWithOptions(value, null, options);\n    }\n\n    return this._validateWithOptions(value, options, callback);\n  }\n\n  describe() {\n    const description = {\n      type: this._type\n    };\n    const flags = Object.keys(this._flags);\n\n    if (flags.length) {\n      if (['empty', 'default', 'lazy', 'label'].some(flag => this._flags.hasOwnProperty(flag))) {\n        description.flags = {};\n\n        for (let i = 0; i < flags.length; ++i) {\n          const flag = flags[i];\n\n          if (flag === 'empty') {\n            description.flags[flag] = this._flags[flag].describe();\n          } else if (flag === 'default') {\n            if (Ref.isRef(this._flags[flag])) {\n              description.flags[flag] = this._flags[flag].toString();\n            } else if (typeof this._flags[flag] === 'function') {\n              description.flags[flag] = {\n                description: this._flags[flag].description,\n                function: this._flags[flag]\n              };\n            } else {\n              description.flags[flag] = this._flags[flag];\n            }\n          } else if (flag === 'lazy' || flag === 'label') {// We don't want it in the description\n          } else {\n            description.flags[flag] = this._flags[flag];\n          }\n        }\n      } else {\n        description.flags = this._flags;\n      }\n    }\n\n    if (this._settings) {\n      description.options = Hoek.clone(this._settings);\n    }\n\n    if (this._baseType) {\n      description.base = this._baseType.describe();\n    }\n\n    if (this._description) {\n      description.description = this._description;\n    }\n\n    if (this._notes.length) {\n      description.notes = this._notes;\n    }\n\n    if (this._tags.length) {\n      description.tags = this._tags;\n    }\n\n    if (this._meta.length) {\n      description.meta = this._meta;\n    }\n\n    if (this._examples.length) {\n      description.examples = this._examples;\n    }\n\n    if (this._unit) {\n      description.unit = this._unit;\n    }\n\n    const valids = this._valids.values();\n\n    if (valids.length) {\n      description.valids = valids.map(v => {\n        return Ref.isRef(v) ? v.toString() : v;\n      });\n    }\n\n    const invalids = this._invalids.values();\n\n    if (invalids.length) {\n      description.invalids = invalids.map(v => {\n        return Ref.isRef(v) ? v.toString() : v;\n      });\n    }\n\n    description.rules = [];\n\n    for (let i = 0; i < this._tests.length; ++i) {\n      const validator = this._tests[i];\n      const item = {\n        name: validator.name\n      };\n\n      if (validator.arg !== void 0) {\n        item.arg = Ref.isRef(validator.arg) ? validator.arg.toString() : validator.arg;\n      }\n\n      const options = validator.options;\n\n      if (options) {\n        if (options.hasRef) {\n          item.arg = {};\n          const keys = Object.keys(validator.arg);\n\n          for (let j = 0; j < keys.length; ++j) {\n            const key = keys[j];\n            const value = validator.arg[key];\n            item.arg[key] = Ref.isRef(value) ? value.toString() : value;\n          }\n        }\n\n        if (typeof options.description === 'string') {\n          item.description = options.description;\n        } else if (typeof options.description === 'function') {\n          item.description = options.description(item.arg);\n        }\n      }\n\n      description.rules.push(item);\n    }\n\n    if (!description.rules.length) {\n      delete description.rules;\n    }\n\n    const label = this._getLabel();\n\n    if (label) {\n      description.label = label;\n    }\n\n    return description;\n  }\n\n  label(name) {\n    Hoek.assert(name && typeof name === 'string', 'Label name must be a non-empty string');\n    const obj = this.clone();\n    obj._flags.label = name;\n    return obj;\n  }\n\n  _getLabel(def) {\n    return this._flags.label || def;\n  }\n\n};\ninternals.Any.prototype.isImmutable = true; // Prevents Hoek from deep cloning schema objects\n// Aliases\n\ninternals.Any.prototype.only = internals.Any.prototype.equal = internals.Any.prototype.valid;\ninternals.Any.prototype.disallow = internals.Any.prototype.not = internals.Any.prototype.invalid;\ninternals.Any.prototype.exist = internals.Any.prototype.required;\ninternals.Any.prototype[internals.symbol] = {\n  version: Pkg.version,\n  compile: Cast.schema,\n  root: '_currentJoi'\n};\n\ninternals._try = function (fn, args = []) {\n  let err;\n  let result;\n\n  try {\n    result = fn(...args);\n  } catch (e) {\n    err = e;\n  }\n\n  return {\n    value: result,\n    error: err\n  };\n};","map":{"version":3,"sources":["C:/Users/Asus A455L/portfolio-rizky/portfolio2/client/node_modules/@hapi/joi/lib/types/any/index.js"],"names":["Hoek","require","Cast","Settings","Ref","Errors","State","Symbols","Pkg","Alternatives","Schemas","internals","Set","symbol","Symbol","for","defaults","abortEarly","convert","allowUnknown","skipFunctions","stripUnknown","language","presence","noDefaults","escapeHtml","module","exports","Any","constructor","isJoi","_type","_settings","_valids","_invalids","_tests","_refs","_flags","_description","_unit","_notes","_tags","_examples","_meta","_inner","_init","schemaType","createError","type","context","state","options","flags","create","createOverrideError","message","template","checkOptions","result","validate","error","Error","details","clone","obj","Object","getPrototypeOf","_currentJoi","_baseType","slice","inners","keys","i","length","key","concat","schema","assert","tmpObj","keysToRestore","merge","push","empty","assign","isObject","source","target","j","sourceKey","_test","name","arg","func","_testUnique","filter","test","strict","isStrict","undefined","raw","isRaw","value","err","self","unknownKeys","k","includes","selfError","allow","values","flatten","remove","add","valid","allowOnly","invalid","required","optional","forbidden","strip","applyFunctionToChildren","children","fn","args","root","extraChildren","map","child","join","default","description","isRef","when","condition","then","otherwise","hasOwnProperty","alternativeOptions","prototype","call","is","desc","notes","Array","isArray","tags","meta","example","examples","processed","unknownOptions","option","localState","parent","_validate","errors","process","ex","unit","_prepareEmptyValue","trim","reference","originalValue","isDefaultOptions","settingsCache","_language","_coerce","coerced","_finalizeValue","isDeepDefault","match","get","insensitive","has","invalids","stripUndefined","_base","base","valids","ret","Err","finalValue","defaultValue","_try","some","e","path","change","reason","_validateWithOptions","callback","settings","resolve","reject","Promise","catch","describe","flag","toString","function","v","rules","validator","item","hasRef","label","_getLabel","def","isImmutable","only","equal","disallow","not","exist","version","compile"],"mappings":"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","sourcesContent":["'use strict';\n\nconst Hoek = require('@hapi/hoek');\n\nconst Cast = require('../../cast');\nconst Settings = require('./settings');\nconst Ref = require('../../ref');\nconst Errors = require('../../errors');\nconst State = require('../state');\nconst Symbols = require('../symbols');\n\nconst Pkg = require('../../../package.json');\n\nlet Alternatives = null;                            // Delay-loaded to prevent circular dependencies\nlet Schemas = null;\n\n\nconst internals = {\n    Set: require('../../set'),\n    symbol: Symbol.for('@hapi/joi/schema')\n};\n\n\ninternals.defaults = {\n    abortEarly: true,\n    convert: true,\n    allowUnknown: false,\n    skipFunctions: false,\n    stripUnknown: false,\n    language: {},\n    presence: 'optional',\n    noDefaults: false,\n    escapeHtml: false\n\n    // context: null\n};\n\n\nmodule.exports = internals.Any = class {\n\n    constructor() {\n\n        this.isJoi = true;\n        this._type = 'any';\n        this._settings = null;\n        this._valids = new internals.Set();\n        this._invalids = new internals.Set();\n        this._tests = [];\n        this._refs = [];\n        this._flags = {\n            /*\n             presence: 'optional',                   // optional, required, forbidden, ignore\n             allowOnly: false,\n             allowUnknown: undefined,\n             default: undefined,\n             forbidden: false,\n             encoding: undefined,\n             insensitive: false,\n             trim: false,\n             normalize: undefined,                   // NFC, NFD, NFKC, NFKD\n             case: undefined,                        // upper, lower\n             empty: undefined,\n             func: false,\n             raw: false\n             */\n        };\n\n        this._description = null;\n        this._unit = null;\n        this._notes = [];\n        this._tags = [];\n        this._examples = [];\n        this._meta = [];\n\n        this._inner = {};                           // Hash of arrays of immutable objects\n    }\n\n    _init() {\n\n        return this;\n    }\n\n    get schemaType() {\n\n        return this._type;\n    }\n\n    createError(type, context, state, options, flags = this._flags) {\n\n        return Errors.create(type, context, state, options, flags);\n    }\n\n    createOverrideError(type, context, state, options, message, template) {\n\n        return Errors.create(type, context, state, options, this._flags, message, template);\n    }\n\n    checkOptions(options) {\n\n        Schemas = Schemas || require('../../schemas');\n\n        const result = Schemas.options.validate(options);\n\n        if (result.error) {\n            throw new Error(result.error.details[0].message);\n        }\n    }\n\n    clone() {\n\n        const obj = Object.create(Object.getPrototypeOf(this));\n\n        obj.isJoi = true;\n        obj._currentJoi = this._currentJoi;\n        obj._type = this._type;\n        obj._settings = this._settings;\n        obj._baseType = this._baseType;\n        obj._valids = this._valids.slice();\n        obj._invalids = this._invalids.slice();\n        obj._tests = this._tests.slice();\n        obj._refs = this._refs.slice();\n        obj._flags = Hoek.clone(this._flags);\n\n        obj._description = this._description;\n        obj._unit = this._unit;\n        obj._notes = this._notes.slice();\n        obj._tags = this._tags.slice();\n        obj._examples = this._examples.slice();\n        obj._meta = this._meta.slice();\n\n        obj._inner = {};\n        const inners = Object.keys(this._inner);\n        for (let i = 0; i < inners.length; ++i) {\n            const key = inners[i];\n            obj._inner[key] = this._inner[key] ? this._inner[key].slice() : null;\n        }\n\n        return obj;\n    }\n\n    concat(schema) {\n\n        Hoek.assert(schema instanceof internals.Any, 'Invalid schema object');\n        Hoek.assert(this._type === 'any' || schema._type === 'any' || schema._type === this._type, 'Cannot merge type', this._type, 'with another type:', schema._type);\n\n        let obj = this.clone();\n\n        if (this._type === 'any' && schema._type !== 'any') {\n\n            // Reset values as if we were \"this\"\n            const tmpObj = schema.clone();\n            const keysToRestore = ['_settings', '_valids', '_invalids', '_tests', '_refs', '_flags', '_description', '_unit',\n                '_notes', '_tags', '_examples', '_meta', '_inner'];\n\n            for (let i = 0; i < keysToRestore.length; ++i) {\n                tmpObj[keysToRestore[i]] = obj[keysToRestore[i]];\n            }\n\n            obj = tmpObj;\n        }\n\n        obj._settings = obj._settings ? Settings.concat(obj._settings, schema._settings) : schema._settings;\n        obj._valids.merge(schema._valids, schema._invalids);\n        obj._invalids.merge(schema._invalids, schema._valids);\n        obj._tests.push(...schema._tests);\n        obj._refs.push(...schema._refs);\n        if (obj._flags.empty && schema._flags.empty) {\n            obj._flags.empty = obj._flags.empty.concat(schema._flags.empty);\n            const flags = Object.assign({}, schema._flags);\n            delete flags.empty;\n            Hoek.merge(obj._flags, flags);\n        }\n        else if (schema._flags.empty) {\n            obj._flags.empty = schema._flags.empty;\n            const flags = Object.assign({}, schema._flags);\n            delete flags.empty;\n            Hoek.merge(obj._flags, flags);\n        }\n        else {\n            Hoek.merge(obj._flags, schema._flags);\n        }\n\n        obj._description = schema._description || obj._description;\n        obj._unit = schema._unit || obj._unit;\n        obj._notes.push(...schema._notes);\n        obj._tags.push(...schema._tags);\n        obj._examples.push(...schema._examples);\n        obj._meta.push(...schema._meta);\n\n        const inners = Object.keys(schema._inner);\n        const isObject = obj._type === 'object';\n        for (let i = 0; i < inners.length; ++i) {\n            const key = inners[i];\n            const source = schema._inner[key];\n            if (source) {\n                const target = obj._inner[key];\n                if (target) {\n                    if (isObject && key === 'children') {\n                        const keys = {};\n\n                        for (let j = 0; j < target.length; ++j) {\n                            keys[target[j].key] = j;\n                        }\n\n                        for (let j = 0; j < source.length; ++j) {\n                            const sourceKey = source[j].key;\n                            if (keys[sourceKey] >= 0) {\n                                target[keys[sourceKey]] = {\n                                    key: sourceKey,\n                                    schema: target[keys[sourceKey]].schema.concat(source[j].schema)\n                                };\n                            }\n                            else {\n                                target.push(source[j]);\n                            }\n                        }\n                    }\n                    else {\n                        obj._inner[key] = obj._inner[key].concat(source);\n                    }\n                }\n                else {\n                    obj._inner[key] = source.slice();\n                }\n            }\n        }\n\n        return obj;\n    }\n\n    _test(name, arg, func, options) {\n\n        const obj = this.clone();\n        obj._tests.push({ func, name, arg, options });\n        return obj;\n    }\n\n    _testUnique(name, arg, func, options) {\n\n        const obj = this.clone();\n        obj._tests = obj._tests.filter((test) => test.name !== name);\n        obj._tests.push({ func, name, arg, options });\n        return obj;\n    }\n\n    options(options) {\n\n        Hoek.assert(!options.context, 'Cannot override context');\n        this.checkOptions(options);\n\n        const obj = this.clone();\n        obj._settings = Settings.concat(obj._settings, options);\n        return obj;\n    }\n\n    strict(isStrict) {\n\n        const obj = this.clone();\n\n        const convert = isStrict === undefined ? false : !isStrict;\n        obj._settings = Settings.concat(obj._settings, { convert });\n        return obj;\n    }\n\n    raw(isRaw) {\n\n        const value = isRaw === undefined ? true : isRaw;\n\n        if (this._flags.raw === value) {\n            return this;\n        }\n\n        const obj = this.clone();\n        obj._flags.raw = value;\n        return obj;\n    }\n\n    error(err, options = { self: false }) {\n\n        Hoek.assert(err && (err instanceof Error || typeof err === 'function'), 'Must provide a valid Error object or a function');\n\n        const unknownKeys = Object.keys(options).filter((k) => !['self'].includes(k));\n        Hoek.assert(unknownKeys.length === 0, `Options ${unknownKeys} are unknown`);\n\n        const obj = this.clone();\n        obj._flags.error = err;\n\n        if (options.self) {\n            obj._flags.selfError = true;\n        }\n\n        return obj;\n    }\n\n    allow(...values) {\n\n        const obj = this.clone();\n        values = Hoek.flatten(values);\n        for (let i = 0; i < values.length; ++i) {\n            const value = values[i];\n\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\n            obj._invalids.remove(value);\n            obj._valids.add(value, obj._refs);\n        }\n\n        return obj;\n    }\n\n    valid(...values) {\n\n        const obj = this.allow(...values);\n        obj._flags.allowOnly = true;\n        return obj;\n    }\n\n    invalid(...values) {\n\n        const obj = this.clone();\n        values = Hoek.flatten(values);\n        for (let i = 0; i < values.length; ++i) {\n            const value = values[i];\n\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\n            obj._valids.remove(value);\n            obj._invalids.add(value, obj._refs);\n        }\n\n        return obj;\n    }\n\n    required() {\n\n        if (this._flags.presence === 'required') {\n            return this;\n        }\n\n        const obj = this.clone();\n        obj._flags.presence = 'required';\n        return obj;\n    }\n\n    optional() {\n\n        if (this._flags.presence === 'optional') {\n            return this;\n        }\n\n        const obj = this.clone();\n        obj._flags.presence = 'optional';\n        return obj;\n    }\n\n\n    forbidden() {\n\n        if (this._flags.presence === 'forbidden') {\n            return this;\n        }\n\n        const obj = this.clone();\n        obj._flags.presence = 'forbidden';\n        return obj;\n    }\n\n\n    strip() {\n\n        if (this._flags.strip) {\n            return this;\n        }\n\n        const obj = this.clone();\n        obj._flags.strip = true;\n        return obj;\n    }\n\n    applyFunctionToChildren(children, fn, args = [], root) {\n\n        children = [].concat(children);\n\n        if (children.length !== 1 || children[0] !== '') {\n            root = root ? (root + '.') : '';\n\n            const extraChildren = (children[0] === '' ? children.slice(1) : children).map((child) => {\n\n                return root + child;\n            });\n\n            throw new Error('unknown key(s) ' + extraChildren.join(', '));\n        }\n\n        return this[fn](...args);\n    }\n\n    default(value, description) {\n\n        if (typeof value === 'function' &&\n            !Ref.isRef(value)) {\n\n            if (!value.description &&\n                description) {\n\n                value.description = description;\n            }\n\n            if (!this._flags.func) {\n                Hoek.assert(typeof value.description === 'string' && value.description.length > 0, 'description must be provided when default value is a function');\n            }\n        }\n\n        const obj = this.clone();\n        obj._flags.default = value;\n        Ref.push(obj._refs, value);\n        return obj;\n    }\n\n    empty(schema) {\n\n        const obj = this.clone();\n        if (schema === undefined) {\n            delete obj._flags.empty;\n        }\n        else {\n            obj._flags.empty = Cast.schema(this._currentJoi, schema);\n        }\n\n        return obj;\n    }\n\n    when(condition, options) {\n\n        Hoek.assert(options && typeof options === 'object', 'Invalid options');\n        Hoek.assert(options.then !== undefined || options.otherwise !== undefined, 'options must have at least one of \"then\" or \"otherwise\"');\n\n        const then = options.hasOwnProperty('then') ? this.concat(Cast.schema(this._currentJoi, options.then)) : undefined;\n        const otherwise = options.hasOwnProperty('otherwise') ? this.concat(Cast.schema(this._currentJoi, options.otherwise)) : undefined;\n\n        Alternatives = Alternatives || require('../alternatives');\n\n        const alternativeOptions = { then, otherwise };\n        if (Object.prototype.hasOwnProperty.call(options, 'is')) {\n            alternativeOptions.is = options.is;\n        }\n\n        const obj = Alternatives.when(condition, alternativeOptions);\n        obj._flags.presence = 'ignore';\n        obj._baseType = this;\n\n        return obj;\n    }\n\n    description(desc) {\n\n        Hoek.assert(desc && typeof desc === 'string', 'Description must be a non-empty string');\n\n        const obj = this.clone();\n        obj._description = desc;\n        return obj;\n    }\n\n    notes(notes) {\n\n        Hoek.assert(notes && (typeof notes === 'string' || Array.isArray(notes)), 'Notes must be a non-empty string or array');\n\n        const obj = this.clone();\n        obj._notes = obj._notes.concat(notes);\n        return obj;\n    }\n\n    tags(tags) {\n\n        Hoek.assert(tags && (typeof tags === 'string' || Array.isArray(tags)), 'Tags must be a non-empty string or array');\n\n        const obj = this.clone();\n        obj._tags = obj._tags.concat(tags);\n        return obj;\n    }\n\n    meta(meta) {\n\n        Hoek.assert(meta !== undefined, 'Meta cannot be undefined');\n\n        const obj = this.clone();\n        obj._meta = obj._meta.concat(meta);\n        return obj;\n    }\n\n    example(...examples) {\n\n        Hoek.assert(examples.length > 0, 'Missing examples');\n\n        const processed = [];\n        for (let i = 0; i < examples.length; ++i) {\n            const example = [].concat(examples[i]);\n            Hoek.assert(example.length <= 2, `Bad example format at index ${i}`);\n\n            const value = example[0];\n            let options = example[1];\n            if (options !== undefined) {\n                Hoek.assert(options && typeof options === 'object', `Options for example at index ${i} must be an object`);\n                const unknownOptions = Object.keys(options).filter((option) => !['parent', 'context'].includes(option));\n                Hoek.assert(unknownOptions.length === 0, `Unknown example options ${unknownOptions} at index ${i}`);\n            }\n            else {\n                options = {};\n            }\n\n            const localState = new State('', [], options.parent || null);\n            const result = this._validate(value, localState, Settings.concat(internals.defaults, options.context ? { context: options.context } : null));\n            Hoek.assert(!result.errors, `Bad example at index ${i}:`, result.errors && Errors.process(result.errors, value));\n\n            const ex = { value };\n            if (Object.keys(options).length) {\n                ex.options = options;\n            }\n\n            processed.push(ex);\n        }\n\n        const obj = this.clone();\n        obj._examples = processed;\n        return obj;\n    }\n\n    unit(name) {\n\n        Hoek.assert(name && typeof name === 'string', 'Unit name must be a non-empty string');\n\n        const obj = this.clone();\n        obj._unit = name;\n        return obj;\n    }\n\n    _prepareEmptyValue(value) {\n\n        if (typeof value === 'string' && this._flags.trim) {\n            return value.trim();\n        }\n\n        return value;\n    }\n\n    _validate(value, state, options, reference) {\n\n        const originalValue = value;\n\n        // Setup state and settings\n\n        state = state || new State('', [], null, reference);\n\n        if (this._settings) {\n            const isDefaultOptions = options === internals.defaults;\n            if (isDefaultOptions && this._settings[Symbols.settingsCache]) {\n                options = this._settings[Symbols.settingsCache];\n            }\n            else {\n                options = Settings.concat(this._language ? Settings.concat({ language: this._language }, options) : options, this._settings);\n                if (isDefaultOptions) {\n                    this._settings[Symbols.settingsCache] = options;\n                }\n            }\n        }\n        else if (this._language) {\n            options = Settings.concat({ language: this._language }, options);\n        }\n\n        let errors = [];\n\n        if (this._coerce) {\n            const coerced = this._coerce(value, state, options);\n            if (coerced.errors) {\n                value = coerced.value;\n                errors = errors.concat(coerced.errors);\n                return this._finalizeValue(value, originalValue, errors, state, options);                            // Coerced error always aborts early\n            }\n\n            value = coerced.value;\n        }\n\n        if (this._flags.empty && !this._flags.empty._validate(this._prepareEmptyValue(value), null, internals.defaults).errors) {\n            value = undefined;\n        }\n\n        // Check presence requirements\n\n        const presence = this._flags.presence || options.presence;\n        if (presence === 'optional') {\n            if (value === undefined) {\n                const isDeepDefault = this._flags.hasOwnProperty('default') && this._flags.default === undefined;\n                if (isDeepDefault && this._type === 'object') {\n                    value = {};\n                }\n                else {\n                    return this._finalizeValue(value, originalValue, errors, state, options);\n                }\n            }\n        }\n        else if (presence === 'required' &&\n            value === undefined) {\n\n            errors.push(this.createError('any.required', null, state, options));\n            return this._finalizeValue(value, originalValue, errors, state, options);\n        }\n        else if (presence === 'forbidden') {\n            if (value === undefined) {\n                return this._finalizeValue(value, originalValue, errors, state, options);\n            }\n\n            errors.push(this.createError('any.unknown', null, state, options));\n            return this._finalizeValue(value, originalValue, errors, state, options);\n        }\n\n        // Check allowed and denied values using the original value\n\n        let match = this._valids.get(value, state, options, this._flags.insensitive);\n        if (match) {\n            if (options.convert) {\n                value = match.value;\n            }\n\n            return this._finalizeValue(value, originalValue, errors, state, options);\n        }\n\n        if (this._invalids.has(value, state, options, this._flags.insensitive)) {\n            errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\n            if (options.abortEarly) {\n\n                return this._finalizeValue(value, originalValue, errors, state, options);\n            }\n        }\n\n        // Convert value and validate type\n\n        if (this._base) {\n            const base = this._base(value, state, options);\n            if (base.errors) {\n                value = base.value;\n                errors = errors.concat(base.errors);\n                return this._finalizeValue(value, originalValue, errors, state, options);                            // Base error always aborts early\n            }\n\n            if (base.value !== value) {\n                value = base.value;\n\n                // Check allowed and denied values using the converted value\n\n                match = this._valids.get(value, state, options, this._flags.insensitive);\n                if (match) {\n                    value = match.value;\n                    return this._finalizeValue(value, originalValue, errors, state, options);\n                }\n\n                if (this._invalids.has(value, state, options, this._flags.insensitive)) {\n                    errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\n                    if (options.abortEarly) {\n                        return this._finalizeValue(value, originalValue, errors, state, options);\n                    }\n                }\n            }\n        }\n\n        // Required values did not match\n\n        if (this._flags.allowOnly) {\n            errors.push(this.createError('any.allowOnly', { value, valids: this._valids.values({ stripUndefined: true }) }, state, options));\n            if (options.abortEarly) {\n                return this._finalizeValue(value, originalValue, errors, state, options);\n            }\n        }\n\n        // Validate tests\n\n        for (let i = 0; i < this._tests.length; ++i) {\n            const test = this._tests[i];\n            const ret = test.func.call(this, value, state, options);\n            if (ret instanceof Errors.Err) {\n                errors.push(ret);\n                if (options.abortEarly) {\n                    return this._finalizeValue(value, originalValue, errors, state, options);\n                }\n            }\n            else {\n                value = ret;\n            }\n        }\n\n        return this._finalizeValue(value, originalValue, errors, state, options);\n    }\n\n    _finalizeValue(value, originalValue, errors, state, options) {\n\n        let finalValue;\n\n        if (value !== undefined) {\n            finalValue = this._flags.raw ? originalValue : value;\n        }\n        else if (options.noDefaults) {\n            finalValue = value;\n        }\n        else if (Ref.isRef(this._flags.default)) {\n            finalValue = this._flags.default(state.parent, options);\n        }\n        else if (typeof this._flags.default === 'function' &&\n            !(this._flags.func && !this._flags.default.description)) {\n\n            let args;\n\n            if (state.parent !== null &&\n                this._flags.default.length > 0) {\n\n                args = [Hoek.clone(state.parent), options];\n            }\n\n            const defaultValue = internals._try(this._flags.default, args);\n            finalValue = defaultValue.value;\n            if (defaultValue.error) {\n                errors.push(this.createError('any.default', { error: defaultValue.error }, state, options));\n            }\n        }\n        else {\n            finalValue = Hoek.clone(this._flags.default);\n        }\n\n        if (errors.length &&\n            typeof this._flags.error === 'function' &&\n            (\n                !this._flags.selfError ||\n                errors.some((e) => state.path.length === e.path.length)\n            )\n        ) {\n            const change = this._flags.error.call(this, errors);\n\n            if (typeof change === 'string') {\n                errors = [this.createOverrideError('override', { reason: errors }, state, options, change)];\n            }\n            else {\n                errors = [].concat(change)\n                    .map((err) => {\n\n                        return err instanceof Error ?\n                            err :\n                            this.createOverrideError(err.type || 'override', err.context, state, options, err.message, err.template);\n                    });\n            }\n        }\n\n        return {\n            value: this._flags.strip ? undefined : finalValue,\n            finalValue,\n            errors: errors.length ? errors : null\n        };\n    }\n\n    _validateWithOptions(value, options, callback) {\n\n        if (options) {\n            this.checkOptions(options);\n        }\n\n        const settings = Settings.concat(internals.defaults, options);\n        const result = this._validate(value, null, settings);\n        const errors = Errors.process(result.errors, value);\n\n        if (callback) {\n            return callback(errors, result.value);\n        }\n\n        return {\n            error: errors,\n            value: result.value,\n            then(resolve, reject) {\n\n                if (errors) {\n                    return Promise.reject(errors).catch(reject);\n                }\n\n                return Promise.resolve(result.value).then(resolve);\n            },\n            catch(reject) {\n\n                if (errors) {\n                    return Promise.reject(errors).catch(reject);\n                }\n\n                return Promise.resolve(result.value);\n            }\n        };\n    }\n\n    validate(value, options, callback) {\n\n        if (typeof options === 'function') {\n            return this._validateWithOptions(value, null, options);\n        }\n\n        return this._validateWithOptions(value, options, callback);\n    }\n\n    describe() {\n\n        const description = {\n            type: this._type\n        };\n\n        const flags = Object.keys(this._flags);\n        if (flags.length) {\n            if (['empty', 'default', 'lazy', 'label'].some((flag) => this._flags.hasOwnProperty(flag))) {\n                description.flags = {};\n                for (let i = 0; i < flags.length; ++i) {\n                    const flag = flags[i];\n                    if (flag === 'empty') {\n                        description.flags[flag] = this._flags[flag].describe();\n                    }\n                    else if (flag === 'default') {\n                        if (Ref.isRef(this._flags[flag])) {\n                            description.flags[flag] = this._flags[flag].toString();\n                        }\n                        else if (typeof this._flags[flag] === 'function') {\n                            description.flags[flag] = {\n                                description: this._flags[flag].description,\n                                function   : this._flags[flag]\n                            };\n                        }\n                        else {\n                            description.flags[flag] = this._flags[flag];\n                        }\n                    }\n                    else if (flag === 'lazy' || flag === 'label') {\n                        // We don't want it in the description\n                    }\n                    else {\n                        description.flags[flag] = this._flags[flag];\n                    }\n                }\n            }\n            else {\n                description.flags = this._flags;\n            }\n        }\n\n        if (this._settings) {\n            description.options = Hoek.clone(this._settings);\n        }\n\n        if (this._baseType) {\n            description.base = this._baseType.describe();\n        }\n\n        if (this._description) {\n            description.description = this._description;\n        }\n\n        if (this._notes.length) {\n            description.notes = this._notes;\n        }\n\n        if (this._tags.length) {\n            description.tags = this._tags;\n        }\n\n        if (this._meta.length) {\n            description.meta = this._meta;\n        }\n\n        if (this._examples.length) {\n            description.examples = this._examples;\n        }\n\n        if (this._unit) {\n            description.unit = this._unit;\n        }\n\n        const valids = this._valids.values();\n        if (valids.length) {\n            description.valids = valids.map((v) => {\n\n                return Ref.isRef(v) ? v.toString() : v;\n            });\n        }\n\n        const invalids = this._invalids.values();\n        if (invalids.length) {\n            description.invalids = invalids.map((v) => {\n\n                return Ref.isRef(v) ? v.toString() : v;\n            });\n        }\n\n        description.rules = [];\n\n        for (let i = 0; i < this._tests.length; ++i) {\n            const validator = this._tests[i];\n            const item = { name: validator.name };\n\n            if (validator.arg !== void 0) {\n                item.arg = Ref.isRef(validator.arg) ? validator.arg.toString() : validator.arg;\n            }\n\n            const options = validator.options;\n            if (options) {\n                if (options.hasRef) {\n                    item.arg = {};\n                    const keys = Object.keys(validator.arg);\n                    for (let j = 0; j < keys.length; ++j) {\n                        const key = keys[j];\n                        const value = validator.arg[key];\n                        item.arg[key] = Ref.isRef(value) ? value.toString() : value;\n                    }\n                }\n\n                if (typeof options.description === 'string') {\n                    item.description = options.description;\n                }\n                else if (typeof options.description === 'function') {\n                    item.description = options.description(item.arg);\n                }\n            }\n\n            description.rules.push(item);\n        }\n\n        if (!description.rules.length) {\n            delete description.rules;\n        }\n\n        const label = this._getLabel();\n        if (label) {\n            description.label = label;\n        }\n\n        return description;\n    }\n\n    label(name) {\n\n        Hoek.assert(name && typeof name === 'string', 'Label name must be a non-empty string');\n\n        const obj = this.clone();\n        obj._flags.label = name;\n        return obj;\n    }\n\n    _getLabel(def) {\n\n        return this._flags.label || def;\n    }\n\n};\n\n\ninternals.Any.prototype.isImmutable = true;     // Prevents Hoek from deep cloning schema objects\n\n// Aliases\n\ninternals.Any.prototype.only = internals.Any.prototype.equal = internals.Any.prototype.valid;\ninternals.Any.prototype.disallow = internals.Any.prototype.not = internals.Any.prototype.invalid;\ninternals.Any.prototype.exist = internals.Any.prototype.required;\n\n\ninternals.Any.prototype[internals.symbol] = {\n    version: Pkg.version,\n    compile: Cast.schema,\n    root: '_currentJoi'\n};\n\n\ninternals._try = function (fn, args = []) {\n\n    let err;\n    let result;\n\n    try {\n        result = fn(...args);\n    }\n    catch (e) {\n        err = e;\n    }\n\n    return {\n        value: result,\n        error: err\n    };\n};\n"]},"metadata":{},"sourceType":"script"}