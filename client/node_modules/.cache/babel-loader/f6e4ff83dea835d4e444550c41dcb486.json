{"ast":null,"code":"'use strict';\n\nconst Assert = require('./assert');\n\nconst DeepEqual = require('./deepEqual');\n\nconst EscapeRegex = require('./escapeRegex');\n\nconst Utils = require('./utils');\n\nconst internals = {};\n\nmodule.exports = function (ref, values, options = {}) {\n  // options: { deep, once, only, part, symbols }\n\n  /*\n      string -> string(s)\n      array -> item(s)\n      object -> key(s)\n      object -> object (key:value)\n  */\n  if (typeof values !== 'object') {\n    values = [values];\n  }\n\n  Assert(!Array.isArray(values) || values.length, 'Values array cannot be empty'); // String\n\n  if (typeof ref === 'string') {\n    return internals.string(ref, values, options);\n  } // Array\n\n\n  if (Array.isArray(ref)) {\n    return internals.array(ref, values, options);\n  } // Object\n\n\n  Assert(typeof ref === 'object', 'Reference must be string or an object');\n  return internals.object(ref, values, options);\n};\n\ninternals.array = function (ref, values, options) {\n  if (!Array.isArray(values)) {\n    values = [values];\n  }\n\n  if (!ref.length) {\n    return false;\n  }\n\n  if (options.only && options.once && ref.length !== values.length) {\n    return false;\n  }\n\n  let compare; // Map values\n\n  const map = new Map();\n\n  for (const value of values) {\n    if (!options.deep || !value || typeof value !== 'object') {\n      const existing = map.get(value);\n\n      if (existing) {\n        ++existing.allowed;\n      } else {\n        map.set(value, {\n          allowed: 1,\n          hits: 0\n        });\n      }\n    } else {\n      compare = compare || internals.compare(options);\n      let found = false;\n\n      for (const [key, existing] of map.entries()) {\n        if (compare(key, value)) {\n          ++existing.allowed;\n          found = true;\n          break;\n        }\n      }\n\n      if (!found) {\n        map.set(value, {\n          allowed: 1,\n          hits: 0\n        });\n      }\n    }\n  } // Lookup values\n\n\n  let hits = 0;\n\n  for (const item of ref) {\n    let match;\n\n    if (!options.deep || !item || typeof item !== 'object') {\n      match = map.get(item);\n    } else {\n      for (const [key, existing] of map.entries()) {\n        if (compare(key, item)) {\n          match = existing;\n          break;\n        }\n      }\n    }\n\n    if (match) {\n      ++match.hits;\n      ++hits;\n\n      if (options.once && match.hits > match.allowed) {\n        return false;\n      }\n    }\n  } // Validate results\n\n\n  if (options.only && hits !== ref.length) {\n    return false;\n  }\n\n  for (const match of map.values()) {\n    if (match.hits === match.allowed) {\n      continue;\n    }\n\n    if (match.hits < match.allowed && !options.part) {\n      return false;\n    }\n  }\n\n  return !!hits;\n};\n\ninternals.object = function (ref, values, options) {\n  Assert(options.once === undefined, 'Cannot use option once with object');\n  const keys = Utils.keys(ref, options);\n\n  if (!keys.length) {\n    return false;\n  } // Keys list\n\n\n  if (Array.isArray(values)) {\n    return internals.array(keys, values, options);\n  } // Key value pairs\n\n\n  const symbols = Object.getOwnPropertySymbols(values).filter(sym => values.propertyIsEnumerable(sym));\n  const targets = [...Object.keys(values), ...symbols];\n  const compare = internals.compare(options);\n  const set = new Set(targets);\n\n  for (const key of keys) {\n    if (!set.has(key)) {\n      if (options.only) {\n        return false;\n      }\n\n      continue;\n    }\n\n    if (!compare(values[key], ref[key])) {\n      return false;\n    }\n\n    set.delete(key);\n  }\n\n  if (set.size) {\n    return options.part ? set.size < targets.length : false;\n  }\n\n  return true;\n};\n\ninternals.string = function (ref, values, options) {\n  // Empty string\n  if (ref === '') {\n    return values.length === 1 && values[0] === '' || // '' contains ''\n    !options.once && !values.some(v => v !== ''); // '' contains multiple '' if !once\n  } // Map values\n\n\n  const map = new Map();\n  const patterns = [];\n\n  for (const value of values) {\n    Assert(typeof value === 'string', 'Cannot compare string reference to non-string value');\n\n    if (value) {\n      const existing = map.get(value);\n\n      if (existing) {\n        ++existing.allowed;\n      } else {\n        map.set(value, {\n          allowed: 1,\n          hits: 0\n        });\n        patterns.push(EscapeRegex(value));\n      }\n    } else if (options.once || options.only) {\n      return false;\n    }\n  }\n\n  if (!patterns.length) {\n    // Non-empty string contains unlimited empty string\n    return true;\n  } // Match patterns\n\n\n  const regex = new RegExp(`(${patterns.join('|')})`, 'g');\n  const leftovers = ref.replace(regex, ($0, $1) => {\n    ++map.get($1).hits;\n    return ''; // Remove from string\n  }); // Validate results\n\n  if (options.only && leftovers) {\n    return false;\n  }\n\n  let any = false;\n\n  for (const match of map.values()) {\n    if (match.hits) {\n      any = true;\n    }\n\n    if (match.hits === match.allowed) {\n      continue;\n    }\n\n    if (match.hits < match.allowed && !options.part) {\n      return false;\n    } // match.hits > match.allowed\n\n\n    if (options.once) {\n      return false;\n    }\n  }\n\n  return !!any;\n};\n\ninternals.compare = function (options) {\n  if (!options.deep) {\n    return internals.shallow;\n  }\n\n  const hasOnly = options.only !== undefined;\n  const hasPart = options.part !== undefined;\n  const flags = {\n    prototype: hasOnly ? options.only : hasPart ? !options.part : false,\n    part: hasOnly ? !options.only : hasPart ? options.part : false\n  };\n  return (a, b) => DeepEqual(a, b, flags);\n};\n\ninternals.shallow = function (a, b) {\n  return a === b;\n};","map":{"version":3,"sources":["C:/Users/Asus A455L/portfolio-rizky/portfolio2/client/node_modules/@hapi/hoek/lib/contain.js"],"names":["Assert","require","DeepEqual","EscapeRegex","Utils","internals","module","exports","ref","values","options","Array","isArray","length","string","array","object","only","once","compare","map","Map","value","deep","existing","get","allowed","set","hits","found","key","entries","item","match","part","undefined","keys","symbols","Object","getOwnPropertySymbols","filter","sym","propertyIsEnumerable","targets","Set","has","delete","size","some","v","patterns","push","regex","RegExp","join","leftovers","replace","$0","$1","any","shallow","hasOnly","hasPart","flags","prototype","a","b"],"mappings":"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","sourcesContent":["'use strict';\n\nconst Assert = require('./assert');\nconst DeepEqual = require('./deepEqual');\nconst EscapeRegex = require('./escapeRegex');\nconst Utils = require('./utils');\n\n\nconst internals = {};\n\n\nmodule.exports = function (ref, values, options = {}) {        // options: { deep, once, only, part, symbols }\n\n    /*\n        string -> string(s)\n        array -> item(s)\n        object -> key(s)\n        object -> object (key:value)\n    */\n\n    if (typeof values !== 'object') {\n        values = [values];\n    }\n\n    Assert(!Array.isArray(values) || values.length, 'Values array cannot be empty');\n\n    // String\n\n    if (typeof ref === 'string') {\n        return internals.string(ref, values, options);\n    }\n\n    // Array\n\n    if (Array.isArray(ref)) {\n        return internals.array(ref, values, options);\n    }\n\n    // Object\n\n    Assert(typeof ref === 'object', 'Reference must be string or an object');\n    return internals.object(ref, values, options);\n};\n\n\ninternals.array = function (ref, values, options) {\n\n    if (!Array.isArray(values)) {\n        values = [values];\n    }\n\n    if (!ref.length) {\n        return false;\n    }\n\n    if (options.only &&\n        options.once &&\n        ref.length !== values.length) {\n\n        return false;\n    }\n\n    let compare;\n\n    // Map values\n\n    const map = new Map();\n    for (const value of values) {\n        if (!options.deep ||\n            !value ||\n            typeof value !== 'object') {\n\n            const existing = map.get(value);\n            if (existing) {\n                ++existing.allowed;\n            }\n            else {\n                map.set(value, { allowed: 1, hits: 0 });\n            }\n        }\n        else {\n            compare = compare || internals.compare(options);\n\n            let found = false;\n            for (const [key, existing] of map.entries()) {\n                if (compare(key, value)) {\n                    ++existing.allowed;\n                    found = true;\n                    break;\n                }\n            }\n\n            if (!found) {\n                map.set(value, { allowed: 1, hits: 0 });\n            }\n        }\n    }\n\n    // Lookup values\n\n    let hits = 0;\n    for (const item of ref) {\n        let match;\n        if (!options.deep ||\n            !item ||\n            typeof item !== 'object') {\n\n            match = map.get(item);\n        }\n        else {\n            for (const [key, existing] of map.entries()) {\n                if (compare(key, item)) {\n                    match = existing;\n                    break;\n                }\n            }\n        }\n\n        if (match) {\n            ++match.hits;\n            ++hits;\n\n            if (options.once &&\n                match.hits > match.allowed) {\n\n                return false;\n            }\n        }\n    }\n\n    // Validate results\n\n    if (options.only &&\n        hits !== ref.length) {\n\n        return false;\n    }\n\n    for (const match of map.values()) {\n        if (match.hits === match.allowed) {\n            continue;\n        }\n\n        if (match.hits < match.allowed &&\n            !options.part) {\n\n            return false;\n        }\n    }\n\n    return !!hits;\n};\n\n\ninternals.object = function (ref, values, options) {\n\n    Assert(options.once === undefined, 'Cannot use option once with object');\n\n    const keys = Utils.keys(ref, options);\n    if (!keys.length) {\n        return false;\n    }\n\n    // Keys list\n\n    if (Array.isArray(values)) {\n        return internals.array(keys, values, options);\n    }\n\n    // Key value pairs\n\n    const symbols = Object.getOwnPropertySymbols(values).filter((sym) => values.propertyIsEnumerable(sym));\n    const targets = [...Object.keys(values), ...symbols];\n\n    const compare = internals.compare(options);\n    const set = new Set(targets);\n\n    for (const key of keys) {\n        if (!set.has(key)) {\n            if (options.only) {\n                return false;\n            }\n\n            continue;\n        }\n\n        if (!compare(values[key], ref[key])) {\n            return false;\n        }\n\n        set.delete(key);\n    }\n\n    if (set.size) {\n        return options.part ? set.size < targets.length : false;\n    }\n\n    return true;\n};\n\n\ninternals.string = function (ref, values, options) {\n\n    // Empty string\n\n    if (ref === '') {\n        return values.length === 1 && values[0] === '' ||               // '' contains ''\n            !options.once && !values.some((v) => v !== '');             // '' contains multiple '' if !once\n    }\n\n    // Map values\n\n    const map = new Map();\n    const patterns = [];\n\n    for (const value of values) {\n        Assert(typeof value === 'string', 'Cannot compare string reference to non-string value');\n\n        if (value) {\n            const existing = map.get(value);\n            if (existing) {\n                ++existing.allowed;\n            }\n            else {\n                map.set(value, { allowed: 1, hits: 0 });\n                patterns.push(EscapeRegex(value));\n            }\n        }\n        else if (options.once ||\n            options.only) {\n\n            return false;\n        }\n    }\n\n    if (!patterns.length) {                     // Non-empty string contains unlimited empty string\n        return true;\n    }\n\n    // Match patterns\n\n    const regex = new RegExp(`(${patterns.join('|')})`, 'g');\n    const leftovers = ref.replace(regex, ($0, $1) => {\n\n        ++map.get($1).hits;\n        return '';                              // Remove from string\n    });\n\n    // Validate results\n\n    if (options.only &&\n        leftovers) {\n\n        return false;\n    }\n\n    let any = false;\n    for (const match of map.values()) {\n        if (match.hits) {\n            any = true;\n        }\n\n        if (match.hits === match.allowed) {\n            continue;\n        }\n\n        if (match.hits < match.allowed &&\n            !options.part) {\n\n            return false;\n        }\n\n        // match.hits > match.allowed\n\n        if (options.once) {\n            return false;\n        }\n    }\n\n    return !!any;\n};\n\n\ninternals.compare = function (options) {\n\n    if (!options.deep) {\n        return internals.shallow;\n    }\n\n    const hasOnly = options.only !== undefined;\n    const hasPart = options.part !== undefined;\n\n    const flags = {\n        prototype: hasOnly ? options.only : hasPart ? !options.part : false,\n        part: hasOnly ? !options.only : hasPart ? options.part : false\n    };\n\n    return (a, b) => DeepEqual(a, b, flags);\n};\n\n\ninternals.shallow = function (a, b) {\n\n    return a === b;\n};\n"]},"metadata":{},"sourceType":"script"}