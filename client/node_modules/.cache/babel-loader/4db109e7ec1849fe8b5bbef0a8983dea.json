{"ast":null,"code":"'use strict';\n\nconst Assert = require('./assert');\n\nconst Clone = require('./clone');\n\nconst Utils = require('./utils');\n\nconst internals = {};\n\nmodule.exports = internals.merge = function (target, source, options) {\n  Assert(target && typeof target === 'object', 'Invalid target value: must be an object');\n  Assert(source === null || source === undefined || typeof source === 'object', 'Invalid source value: must be null, undefined, or an object');\n\n  if (!source) {\n    return target;\n  }\n\n  options = Object.assign({\n    nullOverride: true,\n    mergeArrays: true\n  }, options);\n\n  if (Array.isArray(source)) {\n    Assert(Array.isArray(target), 'Cannot merge array onto an object');\n\n    if (!options.mergeArrays) {\n      target.length = 0; // Must not change target assignment\n    }\n\n    for (let i = 0; i < source.length; ++i) {\n      target.push(Clone(source[i], {\n        symbols: options.symbols\n      }));\n    }\n\n    return target;\n  }\n\n  const keys = Utils.keys(source, options);\n\n  for (let i = 0; i < keys.length; ++i) {\n    const key = keys[i];\n\n    if (key === '__proto__' || !Object.prototype.propertyIsEnumerable.call(source, key)) {\n      continue;\n    }\n\n    const value = source[key];\n\n    if (value && typeof value === 'object') {\n      if (!target[key] || typeof target[key] !== 'object' || Array.isArray(target[key]) !== Array.isArray(value) || value instanceof Date || Buffer && Buffer.isBuffer(value) || // $lab:coverage:ignore$\n      value instanceof RegExp) {\n        target[key] = Clone(value, {\n          symbols: options.symbols\n        });\n      } else {\n        internals.merge(target[key], value, options);\n      }\n    } else {\n      if (value !== null && value !== undefined) {\n        // Explicit to preserve empty strings\n        target[key] = value;\n      } else if (options.nullOverride) {\n        target[key] = value;\n      }\n    }\n  }\n\n  return target;\n};","map":{"version":3,"sources":["C:/Users/Asus A455L/portfolio-rizky/portfolio2/client/node_modules/@hapi/hoek/lib/merge.js"],"names":["Assert","require","Clone","Utils","internals","module","exports","merge","target","source","options","undefined","Object","assign","nullOverride","mergeArrays","Array","isArray","length","i","push","symbols","keys","key","prototype","propertyIsEnumerable","call","value","Date","Buffer","isBuffer","RegExp"],"mappings":"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","sourcesContent":["'use strict';\n\nconst Assert = require('./assert');\nconst Clone = require('./clone');\nconst Utils = require('./utils');\n\n\nconst internals = {};\n\n\nmodule.exports = internals.merge = function (target, source, options) {\n\n    Assert(target && typeof target === 'object', 'Invalid target value: must be an object');\n    Assert(source === null || source === undefined || typeof source === 'object', 'Invalid source value: must be null, undefined, or an object');\n\n    if (!source) {\n        return target;\n    }\n\n    options = Object.assign({ nullOverride: true, mergeArrays: true }, options);\n\n    if (Array.isArray(source)) {\n        Assert(Array.isArray(target), 'Cannot merge array onto an object');\n        if (!options.mergeArrays) {\n            target.length = 0;                                                          // Must not change target assignment\n        }\n\n        for (let i = 0; i < source.length; ++i) {\n            target.push(Clone(source[i], { symbols: options.symbols }));\n        }\n\n        return target;\n    }\n\n    const keys = Utils.keys(source, options);\n    for (let i = 0; i < keys.length; ++i) {\n        const key = keys[i];\n        if (key === '__proto__' ||\n            !Object.prototype.propertyIsEnumerable.call(source, key)) {\n\n            continue;\n        }\n\n        const value = source[key];\n        if (value &&\n            typeof value === 'object') {\n\n            if (!target[key] ||\n                typeof target[key] !== 'object' ||\n                (Array.isArray(target[key]) !== Array.isArray(value)) ||\n                value instanceof Date ||\n                (Buffer && Buffer.isBuffer(value)) ||               // $lab:coverage:ignore$\n                value instanceof RegExp) {\n\n                target[key] = Clone(value, { symbols: options.symbols });\n            }\n            else {\n                internals.merge(target[key], value, options);\n            }\n        }\n        else {\n            if (value !== null &&\n                value !== undefined) {                              // Explicit to preserve empty strings\n\n                target[key] = value;\n            }\n            else if (options.nullOverride) {\n                target[key] = value;\n            }\n        }\n    }\n\n    return target;\n};\n"]},"metadata":{},"sourceType":"script"}