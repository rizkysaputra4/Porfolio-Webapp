{"ast":null,"code":"'use strict';\n\nconst Url = require('url');\n\nconst internals = {\n  minDomainSegments: 2,\n  nonAsciiRx: /[^\\x00-\\x7f]/,\n  domainControlRx: /[\\x00-\\x20@\\:\\/]/,\n  // Control + space + separators\n  tldSegmentRx: /^[a-zA-Z](?:[a-zA-Z0-9\\-]*[a-zA-Z0-9])?$/,\n  domainSegmentRx: /^[a-zA-Z0-9](?:[a-zA-Z0-9\\-]*[a-zA-Z0-9])?$/,\n  URL: Url.URL || URL // $lab:coverage:ignore$\n\n};\n\nexports.analyze = function (domain, options = {}) {\n  if (typeof domain !== 'string') {\n    throw new Error('Invalid input: domain must be a string');\n  }\n\n  if (!domain) {\n    return {\n      error: 'Domain must be a non-empty string'\n    };\n  }\n\n  if (domain.length > 256) {\n    return {\n      error: 'Domain too long'\n    };\n  }\n\n  const ascii = !internals.nonAsciiRx.test(domain);\n\n  if (!ascii) {\n    if (options.allowUnicode === false) {\n      // Defaults to true\n      return {\n        error: 'Domain contains forbidden Unicode characters'\n      };\n    }\n\n    domain = domain.normalize('NFC');\n  }\n\n  if (internals.domainControlRx.test(domain)) {\n    return {\n      error: 'Domain contains invalid character'\n    };\n  }\n\n  domain = internals.punycode(domain); // https://tools.ietf.org/html/rfc1035 section 2.3.1\n\n  const minDomainSegments = options.minDomainSegments || internals.minDomainSegments;\n  const segments = domain.split('.');\n\n  if (segments.length < minDomainSegments) {\n    return {\n      error: 'Domain lacks the minimum required number of segments'\n    };\n  }\n\n  const tlds = options.tlds;\n\n  if (tlds) {\n    const tld = segments[segments.length - 1].toLowerCase();\n\n    if (tlds.deny && tlds.deny.has(tld) || tlds.allow && !tlds.allow.has(tld)) {\n      return {\n        error: 'Domain uses forbidden TLD'\n      };\n    }\n  }\n\n  for (let i = 0; i < segments.length; ++i) {\n    const segment = segments[i];\n\n    if (!segment.length) {\n      return {\n        error: 'Domain contains empty dot-separated segment'\n      };\n    }\n\n    if (segment.length > 63) {\n      return {\n        error: 'Domain contains dot-separated segment that is too long'\n      };\n    }\n\n    if (i < segments.length - 1) {\n      if (!internals.domainSegmentRx.test(segment)) {\n        return {\n          error: 'Domain contains invalid character'\n        };\n      }\n    } else {\n      if (!internals.tldSegmentRx.test(segment)) {\n        return {\n          error: 'Domain contains invalid tld character'\n        };\n      }\n    }\n  }\n};\n\nexports.isValid = function (domain, options) {\n  return !exports.analyze(domain, options);\n};\n\ninternals.punycode = function (domain) {\n  try {\n    return new internals.URL(`http://${domain}`).host;\n  } catch (err) {\n    return domain;\n  }\n};","map":{"version":3,"sources":["C:/Users/Asus A455L/portfolio-rizky/portfolio2/client/node_modules/@hapi/address/lib/domain.js"],"names":["Url","require","internals","minDomainSegments","nonAsciiRx","domainControlRx","tldSegmentRx","domainSegmentRx","URL","exports","analyze","domain","options","Error","error","length","ascii","test","allowUnicode","normalize","punycode","segments","split","tlds","tld","toLowerCase","deny","has","allow","i","segment","isValid","host","err"],"mappings":"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","sourcesContent":["'use strict';\n\nconst Url = require('url');\n\n\nconst internals = {\n    minDomainSegments: 2,\n    nonAsciiRx: /[^\\x00-\\x7f]/,\n    domainControlRx: /[\\x00-\\x20@\\:\\/]/,                                                // Control + space + separators\n    tldSegmentRx: /^[a-zA-Z](?:[a-zA-Z0-9\\-]*[a-zA-Z0-9])?$/,\n    domainSegmentRx: /^[a-zA-Z0-9](?:[a-zA-Z0-9\\-]*[a-zA-Z0-9])?$/,\n    URL: Url.URL || URL                                                                 // $lab:coverage:ignore$\n};\n\n\nexports.analyze = function (domain, options = {}) {\n\n    if (typeof domain !== 'string') {\n        throw new Error('Invalid input: domain must be a string');\n    }\n\n    if (!domain) {\n        return { error: 'Domain must be a non-empty string' };\n    }\n\n    if (domain.length > 256) {\n        return { error: 'Domain too long' };\n    }\n\n    const ascii = !internals.nonAsciiRx.test(domain);\n    if (!ascii) {\n        if (options.allowUnicode === false) {                                           // Defaults to true\n            return { error: 'Domain contains forbidden Unicode characters' };\n        }\n\n        domain = domain.normalize('NFC');\n    }\n\n    if (internals.domainControlRx.test(domain)) {\n        return { error: 'Domain contains invalid character' };\n    }\n\n    domain = internals.punycode(domain);\n\n    // https://tools.ietf.org/html/rfc1035 section 2.3.1\n\n    const minDomainSegments = options.minDomainSegments || internals.minDomainSegments;\n\n    const segments = domain.split('.');\n    if (segments.length < minDomainSegments) {\n        return { error: 'Domain lacks the minimum required number of segments' };\n    }\n\n    const tlds = options.tlds;\n    if (tlds) {\n        const tld = segments[segments.length - 1].toLowerCase();\n        if (tlds.deny && tlds.deny.has(tld) ||\n            tlds.allow && !tlds.allow.has(tld)) {\n\n            return { error: 'Domain uses forbidden TLD' };\n        }\n    }\n\n    for (let i = 0; i < segments.length; ++i) {\n        const segment = segments[i];\n\n        if (!segment.length) {\n            return { error: 'Domain contains empty dot-separated segment' };\n        }\n\n        if (segment.length > 63) {\n            return { error: 'Domain contains dot-separated segment that is too long' };\n        }\n\n        if (i < segments.length - 1) {\n            if (!internals.domainSegmentRx.test(segment)) {\n                return { error: 'Domain contains invalid character' };\n            }\n        }\n        else {\n            if (!internals.tldSegmentRx.test(segment)) {\n                return { error: 'Domain contains invalid tld character' };\n            }\n        }\n    }\n};\n\n\nexports.isValid = function (domain, options) {\n\n    return !exports.analyze(domain, options);\n};\n\n\ninternals.punycode = function (domain) {\n\n    try {\n        return new internals.URL(`http://${domain}`).host;\n    }\n    catch (err) {\n        return domain;\n    }\n};\n"]},"metadata":{},"sourceType":"script"}