{"ast":null,"code":"'use strict';\n\nconst Net = require('net');\n\nconst Address = require('@hapi/address');\n\nconst Hoek = require('@hapi/hoek');\n\nconst Any = require('../any');\n\nconst Ref = require('../../ref');\n\nconst JoiDate = require('../date');\n\nconst Uri = require('./uri');\n\nconst Ip = require('./ip');\n\nconst internals = {\n  uriRegex: Uri.createUriRegex(),\n  ipRegex: Ip.createIpRegex(['ipv4', 'ipv6', 'ipvfuture'], 'optional'),\n  guidBrackets: {\n    '{': '}',\n    '[': ']',\n    '(': ')',\n    '': ''\n  },\n  guidVersions: {\n    uuidv1: '1',\n    uuidv2: '2',\n    uuidv3: '3',\n    uuidv4: '4',\n    uuidv5: '5'\n  },\n  cidrPresences: ['required', 'optional', 'forbidden'],\n  normalizationForms: ['NFC', 'NFD', 'NFKC', 'NFKD']\n};\ninternals.String = class extends Any {\n  constructor() {\n    super();\n    this._type = 'string';\n\n    this._invalids.add('');\n  }\n\n  _base(value, state, options) {\n    if (typeof value === 'string' && options.convert) {\n      if (this._flags.normalize) {\n        value = value.normalize(this._flags.normalize);\n      }\n\n      if (this._flags.case) {\n        value = this._flags.case === 'upper' ? value.toLocaleUpperCase() : value.toLocaleLowerCase();\n      }\n\n      if (this._flags.trim) {\n        value = value.trim();\n      }\n\n      if (this._inner.replacements) {\n        for (let i = 0; i < this._inner.replacements.length; ++i) {\n          const replacement = this._inner.replacements[i];\n          value = value.replace(replacement.pattern, replacement.replacement);\n        }\n      }\n\n      if (this._flags.truncate) {\n        for (let i = 0; i < this._tests.length; ++i) {\n          const test = this._tests[i];\n\n          if (test.name === 'max') {\n            value = value.slice(0, test.arg);\n            break;\n          }\n        }\n      }\n\n      if (this._flags.byteAligned && value.length % 2 !== 0) {\n        value = `0${value}`;\n      }\n    }\n\n    return {\n      value,\n      errors: typeof value === 'string' ? null : this.createError('string.base', {\n        value\n      }, state, options)\n    };\n  }\n\n  insensitive() {\n    if (this._flags.insensitive) {\n      return this;\n    }\n\n    const obj = this.clone();\n    obj._flags.insensitive = true;\n    return obj;\n  }\n\n  creditCard() {\n    return this._test('creditCard', undefined, function (value, state, options) {\n      let i = value.length;\n      let sum = 0;\n      let mul = 1;\n\n      while (i--) {\n        const char = value.charAt(i) * mul;\n        sum = sum + (char - (char > 9) * 9);\n        mul = mul ^ 3;\n      }\n\n      const check = sum % 10 === 0 && sum > 0;\n      return check ? value : this.createError('string.creditCard', {\n        value\n      }, state, options);\n    });\n  }\n\n  regex(pattern, patternOptions) {\n    Hoek.assert(pattern instanceof RegExp, 'pattern must be a RegExp');\n    Hoek.assert(!pattern.flags.includes('g') && !pattern.flags.includes('y'), 'pattern should not use global or sticky mode');\n    const patternObject = {\n      pattern\n    };\n\n    if (typeof patternOptions === 'string') {\n      patternObject.name = patternOptions;\n    } else if (typeof patternOptions === 'object') {\n      patternObject.invert = !!patternOptions.invert;\n\n      if (patternOptions.name) {\n        patternObject.name = patternOptions.name;\n      }\n    }\n\n    const errorCode = ['string.regex', patternObject.invert ? '.invert' : '', patternObject.name ? '.name' : '.base'].join('');\n    return this._test('regex', patternObject, function (value, state, options) {\n      const patternMatch = patternObject.pattern.test(value);\n\n      if (patternMatch ^ patternObject.invert) {\n        return value;\n      }\n\n      return this.createError(errorCode, {\n        name: patternObject.name,\n        pattern: patternObject.pattern,\n        value\n      }, state, options);\n    });\n  }\n\n  alphanum() {\n    return this._test('alphanum', undefined, function (value, state, options) {\n      if (/^[a-zA-Z0-9]+$/.test(value)) {\n        return value;\n      }\n\n      return this.createError('string.alphanum', {\n        value\n      }, state, options);\n    });\n  }\n\n  token() {\n    return this._test('token', undefined, function (value, state, options) {\n      if (/^\\w+$/.test(value)) {\n        return value;\n      }\n\n      return this.createError('string.token', {\n        value\n      }, state, options);\n    });\n  }\n\n  email(validationOptions) {\n    if (validationOptions) {\n      Hoek.assert(typeof validationOptions === 'object', 'email options must be an object'); // Migration validation for unsupported options\n\n      Hoek.assert(validationOptions.checkDNS === undefined, 'checkDNS option is not supported');\n      Hoek.assert(validationOptions.errorLevel === undefined, 'errorLevel option is not supported');\n      Hoek.assert(validationOptions.minDomainAtoms === undefined, 'minDomainAtoms option is not supported, use minDomainSegments instead');\n      Hoek.assert(validationOptions.tldBlacklist === undefined, 'tldBlacklist option is not supported, use tlds.deny instead');\n      Hoek.assert(validationOptions.tldWhitelist === undefined, 'tldWhitelist option is not supported, use tlds.allow instead'); // Validate options\n\n      if (validationOptions.tlds && typeof validationOptions.tlds === 'object') {\n        Hoek.assert(validationOptions.tlds.allow === undefined || validationOptions.tlds.allow === false || validationOptions.tlds.allow === true || Array.isArray(validationOptions.tlds.allow) || validationOptions.tlds.allow instanceof Set, 'tlds.allow must be an array, Set, or boolean');\n        Hoek.assert(validationOptions.tlds.deny === undefined || Array.isArray(validationOptions.tlds.deny) || validationOptions.tlds.deny instanceof Set, 'tlds.deny must be an array or Set');\n\n        const normalizeTable = table => {\n          if (table === undefined || typeof table === 'boolean' || table instanceof Set) {\n            return table;\n          }\n\n          return new Set(table);\n        };\n\n        validationOptions = Object.assign({}, validationOptions); // Shallow cloned\n\n        validationOptions.tlds = {\n          allow: normalizeTable(validationOptions.tlds.allow),\n          deny: normalizeTable(validationOptions.tlds.deny)\n        };\n      }\n\n      Hoek.assert(validationOptions.minDomainSegments === undefined || Number.isSafeInteger(validationOptions.minDomainSegments) && validationOptions.minDomainSegments > 0, 'minDomainSegments must be a positive integer');\n    }\n\n    return this._test('email', validationOptions, function (value, state, options) {\n      if (Address.email.isValid(value, validationOptions)) {\n        return value;\n      }\n\n      return this.createError('string.email', {\n        value\n      }, state, options);\n    });\n  }\n\n  ip(ipOptions = {}) {\n    let regex = internals.ipRegex;\n    Hoek.assert(typeof ipOptions === 'object', 'options must be an object');\n\n    if (ipOptions.cidr) {\n      Hoek.assert(typeof ipOptions.cidr === 'string', 'cidr must be a string');\n      ipOptions.cidr = ipOptions.cidr.toLowerCase();\n      Hoek.assert(Hoek.contain(internals.cidrPresences, ipOptions.cidr), 'cidr must be one of ' + internals.cidrPresences.join(', ')); // If we only received a `cidr` setting, create a regex for it. But we don't need to create one if `cidr` is \"optional\" since that is the default\n\n      if (!ipOptions.version && ipOptions.cidr !== 'optional') {\n        regex = Ip.createIpRegex(['ipv4', 'ipv6', 'ipvfuture'], ipOptions.cidr);\n      }\n    } else {\n      // Set our default cidr strategy\n      ipOptions.cidr = 'optional';\n    }\n\n    let versions;\n\n    if (ipOptions.version) {\n      if (!Array.isArray(ipOptions.version)) {\n        ipOptions.version = [ipOptions.version];\n      }\n\n      Hoek.assert(ipOptions.version.length >= 1, 'version must have at least 1 version specified');\n      versions = [];\n\n      for (let i = 0; i < ipOptions.version.length; ++i) {\n        let version = ipOptions.version[i];\n        Hoek.assert(typeof version === 'string', 'version at position ' + i + ' must be a string');\n        version = version.toLowerCase();\n        Hoek.assert(Ip.versions[version], 'version at position ' + i + ' must be one of ' + Object.keys(Ip.versions).join(', '));\n        versions.push(version);\n      } // Make sure we have a set of versions\n\n\n      versions = Array.from(new Set(versions));\n      regex = Ip.createIpRegex(versions, ipOptions.cidr);\n    }\n\n    return this._test('ip', ipOptions, function (value, state, options) {\n      if (regex.test(value)) {\n        return value;\n      }\n\n      if (versions) {\n        return this.createError('string.ipVersion', {\n          value,\n          cidr: ipOptions.cidr,\n          version: versions\n        }, state, options);\n      }\n\n      return this.createError('string.ip', {\n        value,\n        cidr: ipOptions.cidr\n      }, state, options);\n    });\n  }\n\n  uri(uriOptions) {\n    let customScheme = '';\n    let allowRelative = false;\n    let relativeOnly = false;\n    let allowQuerySquareBrackets = false;\n    let regex = internals.uriRegex;\n\n    if (uriOptions) {\n      Hoek.assert(typeof uriOptions === 'object', 'options must be an object');\n      const unknownOptions = Object.keys(uriOptions).filter(key => !['scheme', 'allowRelative', 'relativeOnly', 'allowQuerySquareBrackets'].includes(key));\n      Hoek.assert(unknownOptions.length === 0, `options contain unknown keys: ${unknownOptions}`);\n\n      if (uriOptions.scheme) {\n        Hoek.assert(uriOptions.scheme instanceof RegExp || typeof uriOptions.scheme === 'string' || Array.isArray(uriOptions.scheme), 'scheme must be a RegExp, String, or Array');\n\n        if (!Array.isArray(uriOptions.scheme)) {\n          uriOptions.scheme = [uriOptions.scheme];\n        }\n\n        Hoek.assert(uriOptions.scheme.length >= 1, 'scheme must have at least 1 scheme specified'); // Flatten the array into a string to be used to match the schemes.\n\n        for (let i = 0; i < uriOptions.scheme.length; ++i) {\n          const scheme = uriOptions.scheme[i];\n          Hoek.assert(scheme instanceof RegExp || typeof scheme === 'string', 'scheme at position ' + i + ' must be a RegExp or String'); // Add OR separators if a value already exists\n\n          customScheme = customScheme + (customScheme ? '|' : ''); // If someone wants to match HTTP or HTTPS for example then we need to support both RegExp and String so we don't escape their pattern unknowingly.\n\n          if (scheme instanceof RegExp) {\n            customScheme = customScheme + scheme.source;\n          } else {\n            Hoek.assert(/[a-zA-Z][a-zA-Z0-9+-\\.]*/.test(scheme), 'scheme at position ' + i + ' must be a valid scheme');\n            customScheme = customScheme + Hoek.escapeRegex(scheme);\n          }\n        }\n      }\n\n      if (uriOptions.allowRelative) {\n        allowRelative = true;\n      }\n\n      if (uriOptions.relativeOnly) {\n        relativeOnly = true;\n      }\n\n      if (uriOptions.allowQuerySquareBrackets) {\n        allowQuerySquareBrackets = true;\n      }\n    }\n\n    if (customScheme || allowRelative || relativeOnly || allowQuerySquareBrackets) {\n      regex = Uri.createUriRegex(customScheme, allowRelative, relativeOnly, allowQuerySquareBrackets);\n    }\n\n    return this._test('uri', uriOptions, function (value, state, options) {\n      if (regex.test(value)) {\n        return value;\n      }\n\n      if (relativeOnly) {\n        return this.createError('string.uriRelativeOnly', {\n          value\n        }, state, options);\n      }\n\n      if (customScheme) {\n        return this.createError('string.uriCustomScheme', {\n          scheme: customScheme,\n          value\n        }, state, options);\n      }\n\n      return this.createError('string.uri', {\n        value\n      }, state, options);\n    });\n  }\n\n  isoDate() {\n    return this._test('isoDate', undefined, function (value, state, options) {\n      if (JoiDate._isIsoDate(value)) {\n        if (!options.convert) {\n          return value;\n        }\n\n        const d = new Date(value);\n\n        if (!isNaN(d.getTime())) {\n          return d.toISOString();\n        }\n      }\n\n      return this.createError('string.isoDate', {\n        value\n      }, state, options);\n    });\n  }\n\n  guid(guidOptions) {\n    let versionNumbers = '';\n\n    if (guidOptions && guidOptions.version) {\n      if (!Array.isArray(guidOptions.version)) {\n        guidOptions.version = [guidOptions.version];\n      }\n\n      Hoek.assert(guidOptions.version.length >= 1, 'version must have at least 1 valid version specified');\n      const versions = new Set();\n\n      for (let i = 0; i < guidOptions.version.length; ++i) {\n        let version = guidOptions.version[i];\n        Hoek.assert(typeof version === 'string', 'version at position ' + i + ' must be a string');\n        version = version.toLowerCase();\n        const versionNumber = internals.guidVersions[version];\n        Hoek.assert(versionNumber, 'version at position ' + i + ' must be one of ' + Object.keys(internals.guidVersions).join(', '));\n        Hoek.assert(!versions.has(versionNumber), 'version at position ' + i + ' must not be a duplicate.');\n        versionNumbers += versionNumber;\n        versions.add(versionNumber);\n      }\n    }\n\n    const guidRegex = new RegExp(`^([\\\\[{\\\\(]?)[0-9A-F]{8}([:-]?)[0-9A-F]{4}\\\\2?[${versionNumbers || '0-9A-F'}][0-9A-F]{3}\\\\2?[${versionNumbers ? '89AB' : '0-9A-F'}][0-9A-F]{3}\\\\2?[0-9A-F]{12}([\\\\]}\\\\)]?)$`, 'i');\n    return this._test('guid', guidOptions, function (value, state, options) {\n      const results = guidRegex.exec(value);\n\n      if (!results) {\n        return this.createError('string.guid', {\n          value\n        }, state, options);\n      } // Matching braces\n\n\n      if (internals.guidBrackets[results[1]] !== results[results.length - 1]) {\n        return this.createError('string.guid', {\n          value\n        }, state, options);\n      }\n\n      return value;\n    });\n  }\n\n  hex(hexOptions = {}) {\n    Hoek.assert(typeof hexOptions === 'object', 'hex options must be an object');\n    Hoek.assert(typeof hexOptions.byteAligned === 'undefined' || typeof hexOptions.byteAligned === 'boolean', 'byteAligned must be boolean');\n    const byteAligned = hexOptions.byteAligned === true;\n    const regex = /^[a-f0-9]+$/i;\n\n    const obj = this._test('hex', regex, function (value, state, options) {\n      if (regex.test(value)) {\n        if (byteAligned && value.length % 2 !== 0) {\n          return this.createError('string.hexAlign', {\n            value\n          }, state, options);\n        }\n\n        return value;\n      }\n\n      return this.createError('string.hex', {\n        value\n      }, state, options);\n    });\n\n    if (byteAligned) {\n      obj._flags.byteAligned = true;\n    }\n\n    return obj;\n  }\n\n  base64(base64Options = {}) {\n    // Validation.\n    Hoek.assert(typeof base64Options === 'object', 'base64 options must be an object');\n    Hoek.assert(typeof base64Options.paddingRequired === 'undefined' || typeof base64Options.paddingRequired === 'boolean', 'paddingRequired must be boolean'); // Determine if padding is required.\n\n    const paddingRequired = base64Options.paddingRequired === false ? base64Options.paddingRequired : base64Options.paddingRequired || true; // Set validation based on preference.\n\n    const regex = paddingRequired ? // Padding is required.\n    /^(?:[A-Za-z0-9+\\/]{2}[A-Za-z0-9+\\/]{2})*(?:[A-Za-z0-9+\\/]{2}==|[A-Za-z0-9+\\/]{3}=)?$/ // Padding is optional.\n    : /^(?:[A-Za-z0-9+\\/]{2}[A-Za-z0-9+\\/]{2})*(?:[A-Za-z0-9+\\/]{2}(==)?|[A-Za-z0-9+\\/]{3}=?)?$/;\n    return this._test('base64', regex, function (value, state, options) {\n      if (regex.test(value)) {\n        return value;\n      }\n\n      return this.createError('string.base64', {\n        value\n      }, state, options);\n    });\n  }\n\n  dataUri(dataUriOptions = {}) {\n    const regex = /^data:[\\w+.-]+\\/[\\w+.-]+;((charset=[\\w-]+|base64),)?(.*)$/; // Determine if padding is required.\n\n    const paddingRequired = dataUriOptions.paddingRequired === false ? dataUriOptions.paddingRequired : dataUriOptions.paddingRequired || true;\n    const base64regex = paddingRequired ? /^(?:[A-Za-z0-9+\\/]{4})*(?:[A-Za-z0-9+\\/]{2}==|[A-Za-z0-9+\\/]{3}=)?$/ : /^(?:[A-Za-z0-9+\\/]{4})*(?:[A-Za-z0-9+\\/]{2}(==)?|[A-Za-z0-9+\\/]{3}=?)?$/;\n    return this._test('dataUri', regex, function (value, state, options) {\n      const matches = value.match(regex);\n\n      if (matches) {\n        if (!matches[2]) {\n          return value;\n        }\n\n        if (matches[2] !== 'base64') {\n          return value;\n        }\n\n        if (base64regex.test(matches[3])) {\n          return value;\n        }\n      }\n\n      return this.createError('string.dataUri', {\n        value\n      }, state, options);\n    });\n  }\n\n  hostname() {\n    const regex = /^(([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\\-]*[a-zA-Z0-9])\\.)*([A-Za-z0-9]|[A-Za-z0-9][A-Za-z0-9\\-]*[A-Za-z0-9])$/;\n    return this._test('hostname', undefined, function (value, state, options) {\n      if (value.length <= 255 && regex.test(value) || Net.isIPv6(value)) {\n        return value;\n      }\n\n      return this.createError('string.hostname', {\n        value\n      }, state, options);\n    });\n  }\n\n  normalize(form = 'NFC') {\n    Hoek.assert(Hoek.contain(internals.normalizationForms, form), 'normalization form must be one of ' + internals.normalizationForms.join(', '));\n\n    const obj = this._test('normalize', form, function (value, state, options) {\n      if (options.convert || value === value.normalize(form)) {\n        return value;\n      }\n\n      return this.createError('string.normalize', {\n        value,\n        form\n      }, state, options);\n    });\n\n    obj._flags.normalize = form;\n    return obj;\n  }\n\n  lowercase() {\n    const obj = this._test('lowercase', undefined, function (value, state, options) {\n      if (options.convert || value === value.toLocaleLowerCase()) {\n        return value;\n      }\n\n      return this.createError('string.lowercase', {\n        value\n      }, state, options);\n    });\n\n    obj._flags.case = 'lower';\n    return obj;\n  }\n\n  uppercase() {\n    const obj = this._test('uppercase', undefined, function (value, state, options) {\n      if (options.convert || value === value.toLocaleUpperCase()) {\n        return value;\n      }\n\n      return this.createError('string.uppercase', {\n        value\n      }, state, options);\n    });\n\n    obj._flags.case = 'upper';\n    return obj;\n  }\n\n  trim(enabled = true) {\n    Hoek.assert(typeof enabled === 'boolean', 'option must be a boolean');\n\n    if (this._flags.trim && enabled || !this._flags.trim && !enabled) {\n      return this;\n    }\n\n    let obj;\n\n    if (enabled) {\n      obj = this._test('trim', undefined, function (value, state, options) {\n        if (options.convert || value === value.trim()) {\n          return value;\n        }\n\n        return this.createError('string.trim', {\n          value\n        }, state, options);\n      });\n    } else {\n      obj = this.clone();\n      obj._tests = obj._tests.filter(test => test.name !== 'trim');\n    }\n\n    obj._flags.trim = enabled;\n    return obj;\n  }\n\n  replace(pattern, replacement) {\n    if (typeof pattern === 'string') {\n      pattern = new RegExp(Hoek.escapeRegex(pattern), 'g');\n    }\n\n    Hoek.assert(pattern instanceof RegExp, 'pattern must be a RegExp');\n    Hoek.assert(typeof replacement === 'string', 'replacement must be a String'); // This can not be considere a test like trim, we can't \"reject\"\n    // anything from this rule, so just clone the current object\n\n    const obj = this.clone();\n\n    if (!obj._inner.replacements) {\n      obj._inner.replacements = [];\n    }\n\n    obj._inner.replacements.push({\n      pattern,\n      replacement\n    });\n\n    return obj;\n  }\n\n  truncate(enabled) {\n    const value = enabled === undefined ? true : !!enabled;\n\n    if (this._flags.truncate === value) {\n      return this;\n    }\n\n    const obj = this.clone();\n    obj._flags.truncate = value;\n    return obj;\n  }\n\n};\n\ninternals.compare = function (type, compare) {\n  return function (limit, encoding) {\n    const isRef = Ref.isRef(limit);\n    Hoek.assert(Number.isSafeInteger(limit) && limit >= 0 || isRef, 'limit must be a positive integer or reference');\n    Hoek.assert(!encoding || Buffer.isEncoding(encoding), 'Invalid encoding:', encoding);\n    return this._test(type, limit, function (value, state, options) {\n      let compareTo;\n\n      if (isRef) {\n        compareTo = limit(state.reference || state.parent, options);\n\n        if (!Number.isSafeInteger(compareTo)) {\n          return this.createError('string.ref', {\n            ref: limit,\n            value: compareTo\n          }, state, options);\n        }\n      } else {\n        compareTo = limit;\n      }\n\n      if (compare(value, compareTo, encoding)) {\n        return value;\n      }\n\n      return this.createError('string.' + type, {\n        limit: compareTo,\n        value,\n        encoding\n      }, state, options);\n    });\n  };\n};\n\ninternals.String.prototype.min = internals.compare('min', (value, limit, encoding) => {\n  const length = encoding ? Buffer.byteLength(value, encoding) : value.length;\n  return length >= limit;\n});\ninternals.String.prototype.max = internals.compare('max', (value, limit, encoding) => {\n  const length = encoding ? Buffer.byteLength(value, encoding) : value.length;\n  return length <= limit;\n});\ninternals.String.prototype.length = internals.compare('length', (value, limit, encoding) => {\n  const length = encoding ? Buffer.byteLength(value, encoding) : value.length;\n  return length === limit;\n}); // Aliases\n\ninternals.String.prototype.uuid = internals.String.prototype.guid;\nmodule.exports = new internals.String();","map":{"version":3,"sources":["C:/Users/Asus A455L/portfolio-rizky/portfolio2/client/node_modules/@hapi/joi/lib/types/string/index.js"],"names":["Net","require","Address","Hoek","Any","Ref","JoiDate","Uri","Ip","internals","uriRegex","createUriRegex","ipRegex","createIpRegex","guidBrackets","guidVersions","uuidv1","uuidv2","uuidv3","uuidv4","uuidv5","cidrPresences","normalizationForms","String","constructor","_type","_invalids","add","_base","value","state","options","convert","_flags","normalize","case","toLocaleUpperCase","toLocaleLowerCase","trim","_inner","replacements","i","length","replacement","replace","pattern","truncate","_tests","test","name","slice","arg","byteAligned","errors","createError","insensitive","obj","clone","creditCard","_test","undefined","sum","mul","char","charAt","check","regex","patternOptions","assert","RegExp","flags","includes","patternObject","invert","errorCode","join","patternMatch","alphanum","token","email","validationOptions","checkDNS","errorLevel","minDomainAtoms","tldBlacklist","tldWhitelist","tlds","allow","Array","isArray","Set","deny","normalizeTable","table","Object","assign","minDomainSegments","Number","isSafeInteger","isValid","ip","ipOptions","cidr","toLowerCase","contain","version","versions","keys","push","from","uri","uriOptions","customScheme","allowRelative","relativeOnly","allowQuerySquareBrackets","unknownOptions","filter","key","scheme","source","escapeRegex","isoDate","_isIsoDate","d","Date","isNaN","getTime","toISOString","guid","guidOptions","versionNumbers","versionNumber","has","guidRegex","results","exec","hex","hexOptions","base64","base64Options","paddingRequired","dataUri","dataUriOptions","base64regex","matches","match","hostname","isIPv6","form","lowercase","uppercase","enabled","compare","type","limit","encoding","isRef","Buffer","isEncoding","compareTo","reference","parent","ref","prototype","min","byteLength","max","uuid","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst Net = require('net');\n\nconst Address = require('@hapi/address');\nconst Hoek = require('@hapi/hoek');\n\nconst Any = require('../any');\nconst Ref = require('../../ref');\nconst JoiDate = require('../date');\n\nconst Uri = require('./uri');\nconst Ip = require('./ip');\n\n\nconst internals = {\n    uriRegex: Uri.createUriRegex(),\n    ipRegex: Ip.createIpRegex(['ipv4', 'ipv6', 'ipvfuture'], 'optional'),\n    guidBrackets: {\n        '{': '}', '[': ']', '(': ')', '': ''\n    },\n    guidVersions: {\n        uuidv1: '1',\n        uuidv2: '2',\n        uuidv3: '3',\n        uuidv4: '4',\n        uuidv5: '5'\n    },\n    cidrPresences: ['required', 'optional', 'forbidden'],\n    normalizationForms: ['NFC', 'NFD', 'NFKC', 'NFKD']\n};\n\n\ninternals.String = class extends Any {\n\n    constructor() {\n\n        super();\n        this._type = 'string';\n        this._invalids.add('');\n    }\n\n    _base(value, state, options) {\n\n        if (typeof value === 'string' &&\n            options.convert) {\n\n            if (this._flags.normalize) {\n                value = value.normalize(this._flags.normalize);\n            }\n\n            if (this._flags.case) {\n                value = (this._flags.case === 'upper' ? value.toLocaleUpperCase() : value.toLocaleLowerCase());\n            }\n\n            if (this._flags.trim) {\n                value = value.trim();\n            }\n\n            if (this._inner.replacements) {\n\n                for (let i = 0; i < this._inner.replacements.length; ++i) {\n                    const replacement = this._inner.replacements[i];\n                    value = value.replace(replacement.pattern, replacement.replacement);\n                }\n            }\n\n            if (this._flags.truncate) {\n                for (let i = 0; i < this._tests.length; ++i) {\n                    const test = this._tests[i];\n                    if (test.name === 'max') {\n                        value = value.slice(0, test.arg);\n                        break;\n                    }\n                }\n            }\n\n            if (this._flags.byteAligned && value.length % 2 !== 0) {\n                value = `0${value}`;\n            }\n        }\n\n        return {\n            value,\n            errors: (typeof value === 'string') ? null : this.createError('string.base', { value }, state, options)\n        };\n    }\n\n    insensitive() {\n\n        if (this._flags.insensitive) {\n            return this;\n        }\n\n        const obj = this.clone();\n        obj._flags.insensitive = true;\n        return obj;\n    }\n\n    creditCard() {\n\n        return this._test('creditCard', undefined, function (value, state, options) {\n\n            let i = value.length;\n            let sum = 0;\n            let mul = 1;\n\n            while (i--) {\n                const char = value.charAt(i) * mul;\n                sum = sum + (char - (char > 9) * 9);\n                mul = mul ^ 3;\n            }\n\n            const check = (sum % 10 === 0) && (sum > 0);\n            return check ? value : this.createError('string.creditCard', { value }, state, options);\n        });\n    }\n\n    regex(pattern, patternOptions) {\n\n        Hoek.assert(pattern instanceof RegExp, 'pattern must be a RegExp');\n        Hoek.assert(!pattern.flags.includes('g') && !pattern.flags.includes('y'), 'pattern should not use global or sticky mode');\n\n        const patternObject = { pattern };\n\n        if (typeof patternOptions === 'string') {\n            patternObject.name = patternOptions;\n        }\n        else if (typeof patternOptions === 'object') {\n            patternObject.invert = !!patternOptions.invert;\n\n            if (patternOptions.name) {\n                patternObject.name = patternOptions.name;\n            }\n        }\n\n        const errorCode = ['string.regex', patternObject.invert ? '.invert' : '', patternObject.name ? '.name' : '.base'].join('');\n\n        return this._test('regex', patternObject, function (value, state, options) {\n\n            const patternMatch = patternObject.pattern.test(value);\n\n            if (patternMatch ^ patternObject.invert) {\n                return value;\n            }\n\n            return this.createError(errorCode, { name: patternObject.name, pattern: patternObject.pattern, value }, state, options);\n        });\n    }\n\n    alphanum() {\n\n        return this._test('alphanum', undefined, function (value, state, options) {\n\n            if (/^[a-zA-Z0-9]+$/.test(value)) {\n                return value;\n            }\n\n            return this.createError('string.alphanum', { value }, state, options);\n        });\n    }\n\n    token() {\n\n        return this._test('token', undefined, function (value, state, options) {\n\n            if (/^\\w+$/.test(value)) {\n                return value;\n            }\n\n            return this.createError('string.token', { value }, state, options);\n        });\n    }\n\n    email(validationOptions) {\n\n        if (validationOptions) {\n            Hoek.assert(typeof validationOptions === 'object', 'email options must be an object');\n\n            // Migration validation for unsupported options\n\n            Hoek.assert(validationOptions.checkDNS === undefined, 'checkDNS option is not supported');\n            Hoek.assert(validationOptions.errorLevel === undefined, 'errorLevel option is not supported');\n            Hoek.assert(validationOptions.minDomainAtoms === undefined, 'minDomainAtoms option is not supported, use minDomainSegments instead');\n            Hoek.assert(validationOptions.tldBlacklist === undefined, 'tldBlacklist option is not supported, use tlds.deny instead');\n            Hoek.assert(validationOptions.tldWhitelist === undefined, 'tldWhitelist option is not supported, use tlds.allow instead');\n\n            // Validate options\n\n            if (validationOptions.tlds &&\n                typeof validationOptions.tlds === 'object') {\n\n                Hoek.assert(validationOptions.tlds.allow === undefined ||\n                    validationOptions.tlds.allow === false ||\n                    validationOptions.tlds.allow === true ||\n                    Array.isArray(validationOptions.tlds.allow) ||\n                    validationOptions.tlds.allow instanceof Set, 'tlds.allow must be an array, Set, or boolean');\n\n                Hoek.assert(validationOptions.tlds.deny === undefined ||\n                    Array.isArray(validationOptions.tlds.deny) ||\n                    validationOptions.tlds.deny instanceof Set, 'tlds.deny must be an array or Set');\n\n                const normalizeTable = (table) => {\n\n                    if (table === undefined ||\n                        typeof table === 'boolean' ||\n                        table instanceof Set) {\n\n                        return table;\n                    }\n\n                    return new Set(table);\n                };\n\n                validationOptions = Object.assign({}, validationOptions);       // Shallow cloned\n                validationOptions.tlds = {\n                    allow: normalizeTable(validationOptions.tlds.allow),\n                    deny: normalizeTable(validationOptions.tlds.deny)\n                };\n            }\n\n            Hoek.assert(validationOptions.minDomainSegments === undefined ||\n                Number.isSafeInteger(validationOptions.minDomainSegments) && validationOptions.minDomainSegments > 0, 'minDomainSegments must be a positive integer');\n        }\n\n        return this._test('email', validationOptions, function (value, state, options) {\n\n            if (Address.email.isValid(value, validationOptions)) {\n                return value;\n            }\n\n            return this.createError('string.email', { value }, state, options);\n        });\n    }\n\n    ip(ipOptions = {}) {\n\n        let regex = internals.ipRegex;\n        Hoek.assert(typeof ipOptions === 'object', 'options must be an object');\n\n        if (ipOptions.cidr) {\n            Hoek.assert(typeof ipOptions.cidr === 'string', 'cidr must be a string');\n            ipOptions.cidr = ipOptions.cidr.toLowerCase();\n\n            Hoek.assert(Hoek.contain(internals.cidrPresences, ipOptions.cidr), 'cidr must be one of ' + internals.cidrPresences.join(', '));\n\n            // If we only received a `cidr` setting, create a regex for it. But we don't need to create one if `cidr` is \"optional\" since that is the default\n            if (!ipOptions.version && ipOptions.cidr !== 'optional') {\n                regex = Ip.createIpRegex(['ipv4', 'ipv6', 'ipvfuture'], ipOptions.cidr);\n            }\n        }\n        else {\n\n            // Set our default cidr strategy\n            ipOptions.cidr = 'optional';\n        }\n\n        let versions;\n        if (ipOptions.version) {\n            if (!Array.isArray(ipOptions.version)) {\n                ipOptions.version = [ipOptions.version];\n            }\n\n            Hoek.assert(ipOptions.version.length >= 1, 'version must have at least 1 version specified');\n\n            versions = [];\n            for (let i = 0; i < ipOptions.version.length; ++i) {\n                let version = ipOptions.version[i];\n                Hoek.assert(typeof version === 'string', 'version at position ' + i + ' must be a string');\n                version = version.toLowerCase();\n                Hoek.assert(Ip.versions[version], 'version at position ' + i + ' must be one of ' + Object.keys(Ip.versions).join(', '));\n                versions.push(version);\n            }\n\n            // Make sure we have a set of versions\n            versions = Array.from(new Set(versions));\n\n            regex = Ip.createIpRegex(versions, ipOptions.cidr);\n        }\n\n        return this._test('ip', ipOptions, function (value, state, options) {\n\n            if (regex.test(value)) {\n                return value;\n            }\n\n            if (versions) {\n                return this.createError('string.ipVersion', { value, cidr: ipOptions.cidr, version: versions }, state, options);\n            }\n\n            return this.createError('string.ip', { value, cidr: ipOptions.cidr }, state, options);\n        });\n    }\n\n    uri(uriOptions) {\n\n        let customScheme = '';\n        let allowRelative = false;\n        let relativeOnly = false;\n        let allowQuerySquareBrackets = false;\n        let regex = internals.uriRegex;\n\n        if (uriOptions) {\n            Hoek.assert(typeof uriOptions === 'object', 'options must be an object');\n\n            const unknownOptions = Object.keys(uriOptions).filter((key) => !['scheme', 'allowRelative', 'relativeOnly', 'allowQuerySquareBrackets'].includes(key));\n            Hoek.assert(unknownOptions.length === 0, `options contain unknown keys: ${unknownOptions}`);\n\n            if (uriOptions.scheme) {\n                Hoek.assert(uriOptions.scheme instanceof RegExp || typeof uriOptions.scheme === 'string' || Array.isArray(uriOptions.scheme), 'scheme must be a RegExp, String, or Array');\n\n                if (!Array.isArray(uriOptions.scheme)) {\n                    uriOptions.scheme = [uriOptions.scheme];\n                }\n\n                Hoek.assert(uriOptions.scheme.length >= 1, 'scheme must have at least 1 scheme specified');\n\n                // Flatten the array into a string to be used to match the schemes.\n                for (let i = 0; i < uriOptions.scheme.length; ++i) {\n                    const scheme = uriOptions.scheme[i];\n                    Hoek.assert(scheme instanceof RegExp || typeof scheme === 'string', 'scheme at position ' + i + ' must be a RegExp or String');\n\n                    // Add OR separators if a value already exists\n                    customScheme = customScheme + (customScheme ? '|' : '');\n\n                    // If someone wants to match HTTP or HTTPS for example then we need to support both RegExp and String so we don't escape their pattern unknowingly.\n                    if (scheme instanceof RegExp) {\n                        customScheme = customScheme + scheme.source;\n                    }\n                    else {\n                        Hoek.assert(/[a-zA-Z][a-zA-Z0-9+-\\.]*/.test(scheme), 'scheme at position ' + i + ' must be a valid scheme');\n                        customScheme = customScheme + Hoek.escapeRegex(scheme);\n                    }\n                }\n            }\n\n            if (uriOptions.allowRelative) {\n                allowRelative = true;\n            }\n\n            if (uriOptions.relativeOnly) {\n                relativeOnly = true;\n            }\n\n            if (uriOptions.allowQuerySquareBrackets) {\n                allowQuerySquareBrackets = true;\n            }\n        }\n\n        if (customScheme || allowRelative || relativeOnly || allowQuerySquareBrackets) {\n            regex = Uri.createUriRegex(customScheme, allowRelative, relativeOnly, allowQuerySquareBrackets);\n        }\n\n        return this._test('uri', uriOptions, function (value, state, options) {\n\n            if (regex.test(value)) {\n                return value;\n            }\n\n            if (relativeOnly) {\n                return this.createError('string.uriRelativeOnly', { value }, state, options);\n            }\n\n            if (customScheme) {\n                return this.createError('string.uriCustomScheme', { scheme: customScheme, value }, state, options);\n            }\n\n            return this.createError('string.uri', { value }, state, options);\n        });\n    }\n\n    isoDate() {\n\n        return this._test('isoDate', undefined, function (value, state, options) {\n\n            if (JoiDate._isIsoDate(value)) {\n                if (!options.convert) {\n                    return value;\n                }\n\n                const d = new Date(value);\n                if (!isNaN(d.getTime())) {\n                    return d.toISOString();\n                }\n            }\n\n            return this.createError('string.isoDate', { value }, state, options);\n        });\n    }\n\n    guid(guidOptions) {\n\n        let versionNumbers = '';\n\n        if (guidOptions && guidOptions.version) {\n            if (!Array.isArray(guidOptions.version)) {\n                guidOptions.version = [guidOptions.version];\n            }\n\n            Hoek.assert(guidOptions.version.length >= 1, 'version must have at least 1 valid version specified');\n            const versions = new Set();\n\n            for (let i = 0; i < guidOptions.version.length; ++i) {\n                let version = guidOptions.version[i];\n                Hoek.assert(typeof version === 'string', 'version at position ' + i + ' must be a string');\n                version = version.toLowerCase();\n                const versionNumber = internals.guidVersions[version];\n                Hoek.assert(versionNumber, 'version at position ' + i + ' must be one of ' + Object.keys(internals.guidVersions).join(', '));\n                Hoek.assert(!(versions.has(versionNumber)), 'version at position ' + i + ' must not be a duplicate.');\n\n                versionNumbers += versionNumber;\n                versions.add(versionNumber);\n            }\n        }\n\n        const guidRegex = new RegExp(`^([\\\\[{\\\\(]?)[0-9A-F]{8}([:-]?)[0-9A-F]{4}\\\\2?[${versionNumbers || '0-9A-F'}][0-9A-F]{3}\\\\2?[${versionNumbers ? '89AB' : '0-9A-F'}][0-9A-F]{3}\\\\2?[0-9A-F]{12}([\\\\]}\\\\)]?)$`, 'i');\n\n        return this._test('guid', guidOptions, function (value, state, options) {\n\n            const results = guidRegex.exec(value);\n\n            if (!results) {\n                return this.createError('string.guid', { value }, state, options);\n            }\n\n            // Matching braces\n            if (internals.guidBrackets[results[1]] !== results[results.length - 1]) {\n                return this.createError('string.guid', { value }, state, options);\n            }\n\n            return value;\n        });\n    }\n\n    hex(hexOptions = {}) {\n\n        Hoek.assert(typeof hexOptions === 'object', 'hex options must be an object');\n        Hoek.assert(typeof hexOptions.byteAligned === 'undefined' || typeof hexOptions.byteAligned === 'boolean',\n            'byteAligned must be boolean');\n\n        const byteAligned = hexOptions.byteAligned === true;\n        const regex = /^[a-f0-9]+$/i;\n\n        const obj = this._test('hex', regex, function (value, state, options) {\n\n            if (regex.test(value)) {\n                if (byteAligned && value.length % 2 !== 0) {\n                    return this.createError('string.hexAlign', { value }, state, options);\n                }\n\n                return value;\n            }\n\n            return this.createError('string.hex', { value }, state, options);\n        });\n\n        if (byteAligned) {\n            obj._flags.byteAligned = true;\n        }\n\n        return obj;\n    }\n\n    base64(base64Options = {}) {\n\n        // Validation.\n        Hoek.assert(typeof base64Options === 'object', 'base64 options must be an object');\n        Hoek.assert(typeof base64Options.paddingRequired === 'undefined' || typeof base64Options.paddingRequired === 'boolean',\n            'paddingRequired must be boolean');\n\n        // Determine if padding is required.\n        const paddingRequired = base64Options.paddingRequired === false ?\n            base64Options.paddingRequired\n            : base64Options.paddingRequired || true;\n\n        // Set validation based on preference.\n        const regex = paddingRequired ?\n            // Padding is required.\n            /^(?:[A-Za-z0-9+\\/]{2}[A-Za-z0-9+\\/]{2})*(?:[A-Za-z0-9+\\/]{2}==|[A-Za-z0-9+\\/]{3}=)?$/\n            // Padding is optional.\n            : /^(?:[A-Za-z0-9+\\/]{2}[A-Za-z0-9+\\/]{2})*(?:[A-Za-z0-9+\\/]{2}(==)?|[A-Za-z0-9+\\/]{3}=?)?$/;\n\n        return this._test('base64', regex, function (value, state, options) {\n\n            if (regex.test(value)) {\n                return value;\n            }\n\n            return this.createError('string.base64', { value }, state, options);\n        });\n    }\n\n    dataUri(dataUriOptions = {}) {\n\n        const regex = /^data:[\\w+.-]+\\/[\\w+.-]+;((charset=[\\w-]+|base64),)?(.*)$/;\n\n        // Determine if padding is required.\n        const paddingRequired = dataUriOptions.paddingRequired === false ?\n            dataUriOptions.paddingRequired\n            : dataUriOptions.paddingRequired || true;\n\n        const base64regex = paddingRequired ?\n            /^(?:[A-Za-z0-9+\\/]{4})*(?:[A-Za-z0-9+\\/]{2}==|[A-Za-z0-9+\\/]{3}=)?$/\n            : /^(?:[A-Za-z0-9+\\/]{4})*(?:[A-Za-z0-9+\\/]{2}(==)?|[A-Za-z0-9+\\/]{3}=?)?$/;\n\n        return this._test('dataUri', regex, function (value, state, options) {\n\n            const matches = value.match(regex);\n\n            if (matches) {\n                if (!matches[2]) {\n                    return value;\n                }\n\n                if (matches[2] !== 'base64') {\n                    return value;\n                }\n\n                if (base64regex.test(matches[3])) {\n                    return value;\n                }\n            }\n\n            return this.createError('string.dataUri', { value }, state, options);\n        });\n    }\n\n    hostname() {\n\n        const regex = /^(([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\\-]*[a-zA-Z0-9])\\.)*([A-Za-z0-9]|[A-Za-z0-9][A-Za-z0-9\\-]*[A-Za-z0-9])$/;\n\n        return this._test('hostname', undefined, function (value, state, options) {\n\n            if ((value.length <= 255 && regex.test(value)) ||\n                Net.isIPv6(value)) {\n\n                return value;\n            }\n\n            return this.createError('string.hostname', { value }, state, options);\n        });\n    }\n\n    normalize(form = 'NFC') {\n\n        Hoek.assert(Hoek.contain(internals.normalizationForms, form), 'normalization form must be one of ' + internals.normalizationForms.join(', '));\n\n        const obj = this._test('normalize', form, function (value, state, options) {\n\n            if (options.convert ||\n                value === value.normalize(form)) {\n\n                return value;\n            }\n\n            return this.createError('string.normalize', { value, form }, state, options);\n        });\n\n        obj._flags.normalize = form;\n        return obj;\n    }\n\n    lowercase() {\n\n        const obj = this._test('lowercase', undefined, function (value, state, options) {\n\n            if (options.convert ||\n                value === value.toLocaleLowerCase()) {\n\n                return value;\n            }\n\n            return this.createError('string.lowercase', { value }, state, options);\n        });\n\n        obj._flags.case = 'lower';\n        return obj;\n    }\n\n    uppercase() {\n\n        const obj = this._test('uppercase', undefined, function (value, state, options) {\n\n            if (options.convert ||\n                value === value.toLocaleUpperCase()) {\n\n                return value;\n            }\n\n            return this.createError('string.uppercase', { value }, state, options);\n        });\n\n        obj._flags.case = 'upper';\n        return obj;\n    }\n\n    trim(enabled = true) {\n\n        Hoek.assert(typeof enabled === 'boolean', 'option must be a boolean');\n\n        if ((this._flags.trim && enabled) || (!this._flags.trim && !enabled)) {\n            return this;\n        }\n\n        let obj;\n        if (enabled) {\n            obj = this._test('trim', undefined, function (value, state, options) {\n\n                if (options.convert ||\n                    value === value.trim()) {\n\n                    return value;\n                }\n\n                return this.createError('string.trim', { value }, state, options);\n            });\n        }\n        else {\n            obj = this.clone();\n            obj._tests = obj._tests.filter((test) => test.name !== 'trim');\n        }\n\n        obj._flags.trim = enabled;\n        return obj;\n    }\n\n    replace(pattern, replacement) {\n\n        if (typeof pattern === 'string') {\n            pattern = new RegExp(Hoek.escapeRegex(pattern), 'g');\n        }\n\n        Hoek.assert(pattern instanceof RegExp, 'pattern must be a RegExp');\n        Hoek.assert(typeof replacement === 'string', 'replacement must be a String');\n\n        // This can not be considere a test like trim, we can't \"reject\"\n        // anything from this rule, so just clone the current object\n        const obj = this.clone();\n\n        if (!obj._inner.replacements) {\n            obj._inner.replacements = [];\n        }\n\n        obj._inner.replacements.push({\n            pattern,\n            replacement\n        });\n\n        return obj;\n    }\n\n    truncate(enabled) {\n\n        const value = enabled === undefined ? true : !!enabled;\n\n        if (this._flags.truncate === value) {\n            return this;\n        }\n\n        const obj = this.clone();\n        obj._flags.truncate = value;\n        return obj;\n    }\n\n};\n\ninternals.compare = function (type, compare) {\n\n    return function (limit, encoding) {\n\n        const isRef = Ref.isRef(limit);\n\n        Hoek.assert((Number.isSafeInteger(limit) && limit >= 0) || isRef, 'limit must be a positive integer or reference');\n        Hoek.assert(!encoding || Buffer.isEncoding(encoding), 'Invalid encoding:', encoding);\n\n        return this._test(type, limit, function (value, state, options) {\n\n            let compareTo;\n            if (isRef) {\n                compareTo = limit(state.reference || state.parent, options);\n\n                if (!Number.isSafeInteger(compareTo)) {\n                    return this.createError('string.ref', { ref: limit, value: compareTo }, state, options);\n                }\n            }\n            else {\n                compareTo = limit;\n            }\n\n            if (compare(value, compareTo, encoding)) {\n                return value;\n            }\n\n            return this.createError('string.' + type, { limit: compareTo, value, encoding }, state, options);\n        });\n    };\n};\n\n\ninternals.String.prototype.min = internals.compare('min', (value, limit, encoding) => {\n\n    const length = encoding ? Buffer.byteLength(value, encoding) : value.length;\n    return length >= limit;\n});\n\n\ninternals.String.prototype.max = internals.compare('max', (value, limit, encoding) => {\n\n    const length = encoding ? Buffer.byteLength(value, encoding) : value.length;\n    return length <= limit;\n});\n\n\ninternals.String.prototype.length = internals.compare('length', (value, limit, encoding) => {\n\n    const length = encoding ? Buffer.byteLength(value, encoding) : value.length;\n    return length === limit;\n});\n\n// Aliases\n\ninternals.String.prototype.uuid = internals.String.prototype.guid;\n\nmodule.exports = new internals.String();\n"]},"metadata":{},"sourceType":"script"}