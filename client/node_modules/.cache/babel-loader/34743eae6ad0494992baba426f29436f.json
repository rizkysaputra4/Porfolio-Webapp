{"ast":null,"code":"'use strict';\n\nconst Util = require('util');\n\nconst Domain = require('./domain');\n\nconst internals = {\n  nonAsciiRx: /[^\\x00-\\x7f]/,\n  encoder: new (Util.TextEncoder || TextEncoder)() // $lab:coverage:ignore$\n\n};\n\nexports.analyze = function (email, options) {\n  return internals.email(email, options);\n};\n\nexports.isValid = function (email, options) {\n  return !internals.email(email, options);\n};\n\ninternals.email = function (email, options = {}) {\n  if (typeof email !== 'string') {\n    throw new Error('Invalid input: email must be a string');\n  }\n\n  if (!email) {\n    return {\n      error: 'Address must be a non-empty string'\n    };\n  } // Unicode\n\n\n  const ascii = !internals.nonAsciiRx.test(email);\n\n  if (!ascii) {\n    if (options.allowUnicode === false) {\n      // Defaults to true\n      return {\n        error: 'Address contains forbidden Unicode characters'\n      };\n    }\n\n    email = email.normalize('NFC');\n  } // Basic structure\n\n\n  const parts = email.split('@');\n\n  if (parts.length !== 2) {\n    return {\n      error: parts.length > 2 ? 'Address cannot contain more than one @ character' : 'Address must contain one @ character'\n    };\n  }\n\n  const [local, domain] = parts;\n\n  if (!local) {\n    return {\n      error: 'Address local part cannot be empty'\n    };\n  }\n\n  if (!options.ignoreLength) {\n    if (email.length > 254) {\n      // http://tools.ietf.org/html/rfc5321#section-4.5.3.1.3\n      return {\n        error: 'Address too long'\n      };\n    }\n\n    if (internals.encoder.encode(local).length > 64) {\n      // http://tools.ietf.org/html/rfc5321#section-4.5.3.1.1\n      return {\n        error: 'Address local part too long'\n      };\n    }\n  } // Validate parts\n\n\n  return internals.local(local, ascii) || Domain.analyze(domain, options);\n};\n\ninternals.local = function (local, ascii) {\n  const segments = local.split('.');\n\n  for (const segment of segments) {\n    if (!segment.length) {\n      return {\n        error: 'Address local part contains empty dot-separated segment'\n      };\n    }\n\n    if (ascii) {\n      if (!internals.atextRx.test(segment)) {\n        return {\n          error: 'Address local part contains invalid character'\n        };\n      }\n\n      continue;\n    }\n\n    for (const char of segment) {\n      if (internals.atextRx.test(char)) {\n        continue;\n      }\n\n      const binary = internals.binary(char);\n\n      if (!internals.atomRx.test(binary)) {\n        return {\n          error: 'Address local part contains invalid character'\n        };\n      }\n    }\n  }\n};\n\ninternals.binary = function (char) {\n  return Array.from(internals.encoder.encode(char)).map(v => String.fromCharCode(v)).join('');\n};\n/*\n    From RFC 5321:\n\n        Mailbox         =   Local-part \"@\" ( Domain / address-literal )\n\n        Local-part      =   Dot-string / Quoted-string\n        Dot-string      =   Atom *(\".\"  Atom)\n        Atom            =   1*atext\n        atext           =   ALPHA / DIGIT / \"!\" / \"#\" / \"$\" / \"%\" / \"&\" / \"'\" / \"*\" / \"+\" / \"-\" / \"/\" / \"=\" / \"?\" / \"^\" / \"_\" / \"`\" / \"{\" / \"|\" / \"}\" / \"~\"\n\n        Domain          =   sub-domain *(\".\" sub-domain)\n        sub-domain      =   Let-dig [Ldh-str]\n        Let-dig         =   ALPHA / DIGIT\n        Ldh-str         =   *( ALPHA / DIGIT / \"-\" ) Let-dig\n\n        ALPHA           =   %x41-5A / %x61-7A        ; a-z, A-Z\n        DIGIT           =   %x30-39                  ; 0-9\n\n    From RFC 6531:\n\n        sub-domain      =/  U-label\n        atext           =/  UTF8-non-ascii\n\n        UTF8-non-ascii  =   UTF8-2 / UTF8-3 / UTF8-4\n\n        UTF8-2          =   %xC2-DF UTF8-tail\n        UTF8-3          =   %xE0 %xA0-BF UTF8-tail /\n                            %xE1-EC 2( UTF8-tail ) /\n                            %xED %x80-9F UTF8-tail /\n                            %xEE-EF 2( UTF8-tail )\n        UTF8-4          =   %xF0 %x90-BF 2( UTF8-tail ) /\n                            %xF1-F3 3( UTF8-tail ) /\n                            %xF4 %x80-8F 2( UTF8-tail )\n\n        UTF8-tail       =   %x80-BF\n\n    Note: The following are not supported:\n\n        RFC 5321: address-literal, Quoted-string\n        RFC 5322: obs-*, CFWS\n*/\n\n\ninternals.atextRx = /^[\\w!#\\$%&'\\*\\+\\-/=\\?\\^`\\{\\|\\}~]+$/; // _ included in \\w\n\ninternals.atomRx = new RegExp([//  %xC2-DF UTF8-tail\n'(?:[\\\\xc2-\\\\xdf][\\\\x80-\\\\xbf])', //  %xE0 %xA0-BF UTF8-tail              %xE1-EC 2( UTF8-tail )            %xED %x80-9F UTF8-tail              %xEE-EF 2( UTF8-tail )\n'(?:\\\\xe0[\\\\xa0-\\\\xbf][\\\\x80-\\\\xbf])|(?:[\\\\xe1-\\\\xec][\\\\x80-\\\\xbf]{2})|(?:\\\\xed[\\\\x80-\\\\x9f][\\\\x80-\\\\xbf])|(?:[\\\\xee-\\\\xef][\\\\x80-\\\\xbf]{2})', //  %xF0 %x90-BF 2( UTF8-tail )            %xF1-F3 3( UTF8-tail )            %xF4 %x80-8F 2( UTF8-tail )\n'(?:\\\\xf0[\\\\x90-\\\\xbf][\\\\x80-\\\\xbf]{2})|(?:[\\\\xf1-\\\\xf3][\\\\x80-\\\\xbf]{3})|(?:\\\\xf4[\\\\x80-\\\\x8f][\\\\x80-\\\\xbf]{2})'].join('|'));","map":{"version":3,"sources":["C:/Users/Asus A455L/portfolio-rizky/portfolio2/client/node_modules/@hapi/address/lib/email.js"],"names":["Util","require","Domain","internals","nonAsciiRx","encoder","TextEncoder","exports","analyze","email","options","isValid","Error","error","ascii","test","allowUnicode","normalize","parts","split","length","local","domain","ignoreLength","encode","segments","segment","atextRx","char","binary","atomRx","Array","from","map","v","String","fromCharCode","join","RegExp"],"mappings":"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","sourcesContent":["'use strict';\n\nconst Util = require('util');\n\nconst Domain = require('./domain');\n\n\nconst internals = {\n    nonAsciiRx: /[^\\x00-\\x7f]/,\n    encoder: new (Util.TextEncoder || TextEncoder)()                                            // $lab:coverage:ignore$\n};\n\n\nexports.analyze = function (email, options) {\n\n    return internals.email(email, options);\n};\n\n\nexports.isValid = function (email, options) {\n\n    return !internals.email(email, options);\n};\n\n\ninternals.email = function (email, options = {}) {\n\n    if (typeof email !== 'string') {\n        throw new Error('Invalid input: email must be a string');\n    }\n\n    if (!email) {\n        return { error: 'Address must be a non-empty string' };\n    }\n\n    // Unicode\n\n    const ascii = !internals.nonAsciiRx.test(email);\n    if (!ascii) {\n        if (options.allowUnicode === false) {                                                   // Defaults to true\n            return { error: 'Address contains forbidden Unicode characters' };\n        }\n\n        email = email.normalize('NFC');\n    }\n\n    // Basic structure\n\n    const parts = email.split('@');\n    if (parts.length !== 2) {\n        return { error: parts.length > 2 ? 'Address cannot contain more than one @ character' : 'Address must contain one @ character' };\n    }\n\n    const [local, domain] = parts;\n\n    if (!local) {\n        return { error: 'Address local part cannot be empty' };\n    }\n\n    if (!options.ignoreLength) {\n        if (email.length > 254) {                                           // http://tools.ietf.org/html/rfc5321#section-4.5.3.1.3\n            return { error: 'Address too long' };\n        }\n\n        if (internals.encoder.encode(local).length > 64) {                  // http://tools.ietf.org/html/rfc5321#section-4.5.3.1.1\n            return { error: 'Address local part too long' };\n        }\n    }\n\n    // Validate parts\n\n    return internals.local(local, ascii) || Domain.analyze(domain, options);\n};\n\n\ninternals.local = function (local, ascii) {\n\n    const segments = local.split('.');\n    for (const segment of segments) {\n        if (!segment.length) {\n            return { error: 'Address local part contains empty dot-separated segment' };\n        }\n\n        if (ascii) {\n            if (!internals.atextRx.test(segment)) {\n                return { error: 'Address local part contains invalid character' };\n            }\n\n            continue;\n        }\n\n        for (const char of segment) {\n            if (internals.atextRx.test(char)) {\n                continue;\n            }\n\n            const binary = internals.binary(char);\n            if (!internals.atomRx.test(binary)) {\n                return { error: 'Address local part contains invalid character' };\n            }\n        }\n    }\n};\n\n\ninternals.binary = function (char) {\n\n    return Array.from(internals.encoder.encode(char)).map((v) => String.fromCharCode(v)).join('');\n};\n\n\n/*\n    From RFC 5321:\n\n        Mailbox         =   Local-part \"@\" ( Domain / address-literal )\n\n        Local-part      =   Dot-string / Quoted-string\n        Dot-string      =   Atom *(\".\"  Atom)\n        Atom            =   1*atext\n        atext           =   ALPHA / DIGIT / \"!\" / \"#\" / \"$\" / \"%\" / \"&\" / \"'\" / \"*\" / \"+\" / \"-\" / \"/\" / \"=\" / \"?\" / \"^\" / \"_\" / \"`\" / \"{\" / \"|\" / \"}\" / \"~\"\n\n        Domain          =   sub-domain *(\".\" sub-domain)\n        sub-domain      =   Let-dig [Ldh-str]\n        Let-dig         =   ALPHA / DIGIT\n        Ldh-str         =   *( ALPHA / DIGIT / \"-\" ) Let-dig\n\n        ALPHA           =   %x41-5A / %x61-7A        ; a-z, A-Z\n        DIGIT           =   %x30-39                  ; 0-9\n\n    From RFC 6531:\n\n        sub-domain      =/  U-label\n        atext           =/  UTF8-non-ascii\n\n        UTF8-non-ascii  =   UTF8-2 / UTF8-3 / UTF8-4\n\n        UTF8-2          =   %xC2-DF UTF8-tail\n        UTF8-3          =   %xE0 %xA0-BF UTF8-tail /\n                            %xE1-EC 2( UTF8-tail ) /\n                            %xED %x80-9F UTF8-tail /\n                            %xEE-EF 2( UTF8-tail )\n        UTF8-4          =   %xF0 %x90-BF 2( UTF8-tail ) /\n                            %xF1-F3 3( UTF8-tail ) /\n                            %xF4 %x80-8F 2( UTF8-tail )\n\n        UTF8-tail       =   %x80-BF\n\n    Note: The following are not supported:\n\n        RFC 5321: address-literal, Quoted-string\n        RFC 5322: obs-*, CFWS\n*/\n\n\ninternals.atextRx = /^[\\w!#\\$%&'\\*\\+\\-/=\\?\\^`\\{\\|\\}~]+$/;               // _ included in \\w\n\n\ninternals.atomRx = new RegExp([\n\n    //  %xC2-DF UTF8-tail\n    '(?:[\\\\xc2-\\\\xdf][\\\\x80-\\\\xbf])',\n\n    //  %xE0 %xA0-BF UTF8-tail              %xE1-EC 2( UTF8-tail )            %xED %x80-9F UTF8-tail              %xEE-EF 2( UTF8-tail )\n    '(?:\\\\xe0[\\\\xa0-\\\\xbf][\\\\x80-\\\\xbf])|(?:[\\\\xe1-\\\\xec][\\\\x80-\\\\xbf]{2})|(?:\\\\xed[\\\\x80-\\\\x9f][\\\\x80-\\\\xbf])|(?:[\\\\xee-\\\\xef][\\\\x80-\\\\xbf]{2})',\n\n    //  %xF0 %x90-BF 2( UTF8-tail )            %xF1-F3 3( UTF8-tail )            %xF4 %x80-8F 2( UTF8-tail )\n    '(?:\\\\xf0[\\\\x90-\\\\xbf][\\\\x80-\\\\xbf]{2})|(?:[\\\\xf1-\\\\xf3][\\\\x80-\\\\xbf]{3})|(?:\\\\xf4[\\\\x80-\\\\x8f][\\\\x80-\\\\xbf]{2})'\n\n].join('|'));\n"]},"metadata":{},"sourceType":"script"}